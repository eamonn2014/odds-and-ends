---
title: "Negative binomial distributions" 
author: 
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: scroll
    social: menu
    source_code: embed
runtime: shiny
---
Probability mass functions
===

```{r global, include=FALSE}

  rm(list=ls())
  set.seed(6453)
  library(MASS)      # for neg binomial analysis and correlated data generation
  library(ggplot2)
  library(shiny)
  library(utf8)      # codes for Greek letters
  library(gridExtra)
  library(tidyverse)
 
  lwd.=3             # used when plotting
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # function to format decimals
  # https://stackoverflow.com/questions/3245862/format-numbers-to-significant-figures-nicely-in-r
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  formatz <- function(x){
    
    if (!is.na(x)  ) {
      
      formatC(signif(x,digits=5), digits=5,format="fg", flag="#",big.mark=",")
      
    }
    
  }
  
  formatz0 <- function(x){
    sprintf(x, fmt = '%s')  
  }
  formatz1 <- function(x){
    sprintf(x, fmt = '%#.1f')  
  }
  formatz2 <- function(x){
    sprintf(x, fmt = '%#.2f')  
  }
  formatz00 <- function(x){
    round(x,0) 
  }
  formatz3 <- function(x){
    sprintf(x, fmt = '%#.3f')  
  }
  formatz4 <- function(x){
    sprintf(x, fmt = '%#.4f')  
  }
  
  
  
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# function for nice upper limits to count bar plots, stack exchange
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
    roundUpNice <- function(x, nice=c(1,1.5, 2,4,5,6,8,10)) { #added 1.5 to help bar plot y scale
    if(length(x) != 1) stop("'x' must be of length 1")
    10^floor(log10(x)) * nice[[which(x <= 10^floor(log10(x)) * nice)[[1]]]]
  }
  
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define the Negative Binomial probability density function, with parameters
# mu and alpha. The mean of this NB distribution is mu, and variance is sigma^2=mu+alpha*mu^2
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
   e_dnbinom=function(x,mu,alpha){
     
    k = 1/alpha
    s1 = lgamma(k+x)-lgamma(k)-lgamma(x+1)    # lgamma is log(gamma)
    s2 = x*log(mu/(mu+k))
    s3 = -k*log(1+mu/k)
    prob = exp(s1+s2+s3)
    prob[x<0] = 0
    prob[prob>1] = 1
    prob[prob<0] = 0
    return(prob)
    
  }

# check
# dnbinom(   1, size=2,   mu=3)
# e_dnbinom(1, alpha=1/2,mu=3)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This function translates the mu and alpha parameters into size and prob
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
  e_rnbinom=function(n,mu,alpha){
    size = 1/alpha          # so now we can just enter alpha this is converted to 1/ alpha
    prob = size/(mu+size)   # so now we can enter mu the mean and that is converted to prob
    return(rnbinom(n,size=size,prob=prob))
  }

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
   e_nb=function(mu,alpha){
     size = 1/alpha          # so now we can just enter alpha this is converted to 1/ alpha
     prob = size/(mu+size)   # so now we can enter mu the mean and that is converted to prob
     return(list(prob=prob,size=size))
   }
   
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # here is where prob and size are converted to mu and alpha
  #https://geek-questions.imtqy.com/articles/1785935/index.html
   rev_nb=function(prob,size){
    alpha = 1/size          # so now we can just enter alpha this is converted to 1/ alpha
    mu = size/prob - size    # so now we can enter mu the mean and that is converted to prob
    return(list(mu=mu, alpha=alpha))
   }
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
    x <- e_nb(mu=15, alpha=1.2)
    x
    rev_nb(size=x$size, prob=x$prob)
    # 
    # x<-10
    # k = 1.2
    # mu = 15
    # 
    # p = k/(k+mu)   #1
    # s = mu*p/(1-p) #2
    # 
    # dnbinom(x,size=s,prob=p)
    # dnbinom(x,mu=mu,size=k)
    #  
    # mu <- ( k/p - k )     

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# number of successes function to simulate neg binomial simulation
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
 foo <- function(p = 0.5, s = 4) { # p prob of success; s 
  
  i <- 0 # count of how many attempt we need to get s successes
  x <- 0 # use this to know when to stop function
  
  while ( x < s) {  # stop when x equals s 
    
    i <- i + 1  # count every attempt
    
    res <-  rbinom(1, size=1, prob=p)  # a la coin flip, heads is success
    
    if (res ==1) {x=x+1}   # if heads count , if not we fail
   
  }
  return(i) # result captured here
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# start of app
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

```

Column {.sidebar}
-----------------------------------------------------------------------

**Count data analysis is explored**

```{r tab1}

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

  sliderInput('mu', 'Top panels \u03BC', value=3,
                min = 1, max = 25, step=.5, ticks=F)
  
  sliderInput('alpha_a', 'Top panels \u03B1', value = c(1/3),
                min = 0, max = 5 ,step=0.01, ticks=F)
 
  sliderInput('P', 'Probability of Success (bottom panels)', value=.5,
                min = 0.01, max = 1, step=.01, ticks=F)
  
  sliderInput('s', 'No of successess (bottom panels)', value = c(3),
                min = 1, max = 200 ,step=1, ticks=F)
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
  
  sliderInput('sims', 'Simulations (bottom left panel)', 15000,
                min = 1000, max = 20000, step=1000,ticks=F)
  
  sliderInput('x_range', 'Plot x-range', value = c(0,10),
          min = 0, max = 80,step=5,ticks=F)
  
  sliderInput('y_range', 'Plot y-range', value = c(0,.25),
          min = 0, max = 1,step=.05,ticks=F)

  checkboxInput('perc','show stats on barplot', value=TRUE)

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

```

$\alpha$ takes on positive rational values, rarely above 4. Values of $\alpha$ greater than 2 usually indicate that there is substantial over-dispersion.

When $\alpha$ approaches 0, k approaches infinity and Poisson emerges (move red $\alpha$ slider to 0).

When $\alpha$ > 1, k < 1 leads to over dispersed data.

$\alpha$ = 1/k ; k = 1/ $\alpha$ see next tab.
 

Column {data-width=400, height=300}
-----------------------------------------------------------------------
### Negative binomial couched in terms of mu and alpha


```{r tab1 plot1, eval=TRUE}

 
        renderPlot({
  
      mu = input$mu
      alpha_a = input$alpha_a
          
      low =  input$x_range[1]
      xmax=  input$x_range[2]
      ymax = input$y_range[2]

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  xx <- c(seq(0,xmax,1)) 

  if(alpha_a==0) {
    yb =    dpois(xx,mu)
  }else{
    yb=     e_dnbinom(xx,mu,alpha_a)
  }

  b <- barplot(yb, xlim=c(0,xmax+2), ylab = "Percent", xlab="Count of failed attempts (X-r)", col='lightgreen',
          ylim=c(0,ymax),
          main =  paste0("Negative Binomial \u03BC = ",mu," \u03B1 = ",formatz2(alpha_a),", variance = ", (mu+alpha_a*mu^2),""), # mu+alpha_a*mu^2* alpha_a
          names.arg= as.character(xx))
  
  if(input$perc) {
    x  <- 0:length(b) # % onto top of bars
    y1 <- yb + 0.02
    z  <- round(yb,2) *100
    z  <- paste0(z,"%")
    text(x=b[x+1],y=(y1),labels=z, cex = 1)
  }
})
    
 
```

### Negative binomial mu and alpha converted to probability of success and number of successful attempts  

```{r, tab1 plot2, eval=TRUE}

  renderPlot({
    
    
  sim <- input$sims
  # P <- input$P   # randomly pick a probability
  
  z <- e_nb(input$mu, input$alpha_a)
 
  P = z[1][[1]]
  s = z[2][[1]]
  
  #low =  input$x_range[1]
  xmax=  input$x_range[2]
  ymax = input$y_range[2]
 # ymin = input$y_range[1]

  
  # simulation bar plot
  #!!!!!!!!!!!!!!!!!!!!!!this is actually not used
  number_of_attempts <- replicate(sim, foo(p=P,s=s))  # run function many times
   
  Tm <-  1/P*s 
  Sm <- mean(number_of_attempts) 
  
  x <- table(factor(number_of_attempts, levels = s: max(number_of_attempts))) # pad out so levels so no counts included
   
  m = length(x)-1
  z <- (0:m)+3 # labels
  d <- dnbinom(0:m, prob=P, size=s)
  b <- barplot(d , #x/sim, 
               
               xlim=c(0,xmax+2),  
               ylim=c(0,ymax),
               main = paste0("Number of attempts until we reach ",s," successes when p=",formatz2(P),
                                    "\n True \u03BC ",formatz2(Tm) , #" ; Simulated \u03BC (green) ",formatz2(Sm) ,
                             ""),
               col="orchid1", 
               ylab="Probability of success", 
               xlab="Attempts for success (no simulation); note we can get non-integers!",
               names.arg= as.character(z))
  
  # overlay true neg binomial dist.
  #m <- length(b)-1
 
#  d <- dnbinom(0:m, prob=P, size=s) # s was 0 and ymax was m
# no need for these points and lines...
# lines( x = b, y = d , col='red')
 # points(x = b, y = d , col='red')
 
    if(input$perc) {
      
        x  <-0:length(b) # % onto top of bars
        y1 <- d + 0.02
        z  <- round(d,2) *100
        z  <- paste0(z,"%")
        text(x=b[x+1],y=(y1),labels=z, cex = 1)
}
  })

```

Column {data-width=400}
-------------------------------------

### Negative binomial couched in terms of probability of success and number of successesful attempts

```{r, tab1 plot3, eval=TRUE}
 
 renderPlot({

  sim <- input$sims
  P <- input$P   # randomly pick a probability
  if (P==0) P=0.01
  s <- input$s   # randomly pick nth success
  
  #low =  input$x_range[1]
  xmax=  input$x_range[2]
  ymax = input$y_range[2]
 # ymin = input$y_range[1]
   
  # simulation bar plot
  number_of_attempts <- replicate(sim, foo(p=P,s=s))  # run function many times
  
  #Tm <- s*(1-P)/P + s
  Tm <-  1/P*s 
  Sm <- mean(number_of_attempts) 
  
 
  x <- table(factor(number_of_attempts, levels = s: max(number_of_attempts))) # pad out so levels so no counts included
  
 # x <- table(factor(number_of_attempts, levels = s: ymax)) # pad out so levels so no counts included

  b <- barplot(x/sim, 
               
               xlim=c(0,xmax+2),  
               ylim=c(0,ymax),
               main = paste0("Number of attempts until we reach ",s," successes when p=",formatz2(P),
                                    "\n True \u03BC ",formatz2(Tm) ," ; Simulated \u03BC (lilac) ",formatz2(Sm) ,""),
                                    
               col="orchid1", 
               ylab="Probability of success", 
               xlab="Attempts for success (simulated in lilac, true negative binomial distribution red line with true %s above bars)")
  
  # overlay true neg binomial dist.
  m <- length(b)-1
 
  # d <- dnbinom(s:ymax, prob=P, size=s) # s was 0 and ymax was m
  
  d <- dnbinom(0:m, prob=P, size=s) # s was 0 and ymax was m

  lines( x = b, y = d , col='red')
  points(x = b, y = d , col='red')
 
    if(input$perc) {
      
        x  <-0:length(b) # % onto top of bars
        y1 <- d + 0.02
        z  <- round(d,2) *100
        z  <- paste0(z,"%")
        text(x=b[x+1],y=(y1),labels=z, cex = 1)
  }

 })


```

###  Negative binomial probability of success and number of successful attempts converted to mu and alpha


```{r, tab1 plot4}

    renderPlot({
  
    z <-  rev_nb(input$P, input$s)
    
    mu = z[1][[1]]
    alpha_a = z[2][[1]]
        
    low =  input$x_range[1]
    xmax=  input$x_range[2]
    ymax = input$y_range[2]

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  xx <- c(seq(0,xmax,1)) 

  if(alpha_a==0) {
    yb =    dpois(xx,mu)
  }else{
    yb=     e_dnbinom(xx,mu,alpha_a)
  }

  b <- barplot(yb, xlim=c(0,xmax+2), ylab = "Percent", xlab="Count of failed attempts (X-r)", col='lightgreen',
          ylim=c(0,ymax),
          main =  paste0("Negative Binomial \u03BC = ",mu," \u03B1 = ",formatz2(alpha_a),", variance = ", mu+alpha_a*mu^2,""),
          names.arg= as.character(xx))
  
  if(input$perc) {
    x  <- 0:length(b) # % onto top of bars
    y1 <- yb + 0.02
    z  <- round(yb,2) *100
    z  <- paste0(z,"%")
    text(x=b[x+1],y=(y1),labels=z, cex = 1)
  }
})

```


Probability mass functions 2
===


Column {.sidebar}
-----------------------------------------------------------------------

**The negative binomial distribution asks : what is the probability that the rth success will occur on the kth trial, where k varies from r to infinity, given a fixed r, and a fixed probability of success on each trial?**

```{r tab1x}


  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
 
 
  sliderInput('Px', 'Probability of Success (p)', value=.5,
                min = 0.01, max = 1, step=.01, ticks=F)
  
  sliderInput('sx', 'No of successess (r)', value = c(3),
                min = 1, max = 50 ,step=1, ticks=F)

  sliderInput('x_rangex', 'Plot x-range', value = c(0,10),
          min = 0, max = 80,step=5,ticks=F)
  
  sliderInput('y_rangex', 'Plot y-range', value = c(0,.25),
          min = 0, max = 1,step=.05,ticks=F)

  checkboxInput('percx','show stats on barplot', value=TRUE)

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
 


```

Recall that a binomial random variable is a count of the number of successes in n Bernoulli
trials. That is, the number of trials is predetermined, and the number of successes is random.
A negative binomial random variable is a count of the number of trials required to obtain r successes. That is, the number of successes is predetermined, and the number of trials is random

Column {data-width=400} 
-----------------------------------------------------------------------

### Negative binomial couched in terms of probability of success and number of successesful attempts


```{r, tab1 plot3x, eval=TRUE}
 
 renderPlot({

     par(mar=c(5.1, 4.1, 4.1, 7.1), mgp=c(3, 1, 0), las=0) # http://rfunction.com/archives/1302

  P <- input$Px   # probability of success
  if (P==0) P=0.01
  s <- input$sx   # th success

  
  mu <- s / P
  mu2 <- (s*P)/(1-P)
  #mean(rnbinom(n = 10000, size = s, prob = p)) + s
  # https://bookdown.org/mpfoley1973/data-sci/negative-binomial.html
  # Variance of distribution = (Number of success*Probability of Failure)/(Probability of Success^2)
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   
  #~~~~~~~~~~~~~~~~~~~~~~~~
  # Wikipedia: When counting the number of successes given the number r of failures, 
  # the variance is rp/(1 − p)2. When counting the number of failures before the r-th success, 
  # the variance is r(1 − p)/p2.
  v <- s * (1 - P) / P^2
  v2 <- s * P/ (1 - P)^2
  
  #s=3;P=0.2
  #x <- rnbinom(n = 100000, size = s, prob = P)
  #mean(x);var(x)
  
 
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  xmax=  input$x_rangex[2]
  ymax = input$y_rangex[2]

  xx <- c(seq(0,xmax,1)) 
  d <- dnbinom(0:max(xx), prob=P, size=s) #
   
  #Tm <- s*(1-P)/P + s
  #Tm <-  1/P*s 

  b <- barplot(d, 
               xlim=c(0,xmax+2),  
               ylim=c(0,ymax),
               main = paste0("Probability of ",s," successes on kth trial when probability of success is ",formatz2(P),
                                    ". Average number of trials \u03BC (r/p) = ",formatz2(mu) ,";
                              The expected number of failures prior to r successes is r(1-p)/p = ",s * (1 - P) / P," with variance r(1-p)/p^2 = ",v,". Average number of successes rp/(1 − p) = ",mu2,".\n Counting the number of successes given the number r of failures, the variance is rp/(1 − p)^2 = ",v2,"\nxxxxxxxxxxxxxx"),
                                    
               col="orchid1", 
               ylab="Probability of success", 
               xlab=paste("Attempts for ",s," successes"),
               names.arg= as.character(xx+s))
 
 
    if(input$percx) {
      
        x  <-0:length(b) # % onto top of bars
        y1 <- d + 0.02
        z  <- round(d,4) *100
        z  <- paste0(z,"%")
        text(x=b[x+1],y=(y1),labels=z, cex = 1)
  }
par(mar=c(5.1, 4.1, 4.1, 2.1), mgp=c(3, 1, 0), las=0)
 })


 

```

Column {data-width=400}
-------------------------------------

### c

```{r, tab1 plot4x, eval=TRUE}

renderPlot({
  
  par(mar=c(5.1, 4.1, 4.1, 7.1), mgp=c(3, 1, 0), las=0)
  
    z <-  rev_nb(input$Px, input$sx)
    
    mu = z[1][[1]]
    alpha_a = z[2][[1]]
        
    low =  input$x_rangex[1]
    xmax=  input$x_rangex[2]
    ymax = input$y_rangex[2]

   #  r <- input$sx 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  xx <- c(seq(0,xmax,1)) 

  if(alpha_a==0) {
    yb =    dpois(xx,mu)
  }else{
    yb=     e_dnbinom(xx,mu,alpha_a)
  }

# check the variance calculation
  
  
  
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# my code from when ttests won't do
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # value <- 0:200
  # freq <- e_dnbinom(value, alpha=1/3,mu=3)*100
  # 
  # mu<-sum(freq*value)/sum(freq)
  # va<-(sum(freq*(value-mu)^2)/(sum(freq)-1) ) 
  # 
  # mu
  # va
  # #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # freq <- dnbinom(value, size3,mu=3)*100
  # 
  # mu<-sum(freq*value)/sum(freq)
  # va<-(sum(freq*(value-mu)^2)/(sum(freq)-1) ) 
  # 
  # mu
  # va
  
  # lets do a sanity check on mean and variance and report them as qc check in plot
  value <-   0:1000000   # replaced xx 
  freq  <-  e_dnbinom(value, alpha=alpha_a,mu=mu)*100
  mux   <-  sum(freq*value)/sum(freq)
  vax   <- (sum(freq*(value-mu)^2)/(sum(freq)-0) ) # I changed the 0 from 1 !!
  
  mux
  vax
  
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# end 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  
  
  b <- barplot(yb, xlim=c(0,xmax+2), ylab = "Percent", xlab="Count of failed attempts (X-r)", col='lightgreen',
          ylim=c(0,ymax),
          main =  paste0("Negative Binomial \u03BC = ",formatz2(mu)," \u03B1 = ",formatz2(alpha_a),", variance = ", formatz2(mu+alpha_a*mu^2)," [qc check mu =  ",formatz2(mux),"; qc check variance = ",formatz2(vax),"]"),
          names.arg= as.character(xx))
  
  if(input$perc) {
    x  <- 0:length(b) # % onto top of bars
    y1 <- yb + 0.02
    z  <- round(yb,4) *100
    z  <- paste0(z,"%")
    text(x=b[x+1],y=(y1),labels=z, cex = 1)
    
    par(mar=c(5.1, 4.1, 4.1, 2.1), mgp=c(3, 1, 0), las=0)
  }
})

```

 