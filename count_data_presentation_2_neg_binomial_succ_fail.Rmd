---
title: "Negative binomial distributions" 
author: 
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: scroll
    social: menu
    source_code: embed
runtime: shiny
---
Probability mass functions
===

```{r global, include=FALSE}

  rm(list=ls())
  set.seed(6453)
  library(MASS)      # for neg binomial analysis and correlated data generation
  library(ggplot2)
  library(shiny)
  library(utf8)      # codes for Greek letters
  library(gridExtra)
  library(tidyverse)
 
  lwd.=3             # used when plotting
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # function to format decimals
  # https://stackoverflow.com/questions/3245862/format-numbers-to-significant-figures-nicely-in-r
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  formatz <- function(x){
    
    if (!is.na(x)  ) {
      
      formatC(signif(x,digits=5), digits=5,format="fg", flag="#",big.mark=",")
      
    }
    
  }
  
  formatz0 <- function(x){
    sprintf(x, fmt = '%s')  
  }
  formatz1 <- function(x){
    sprintf(x, fmt = '%#.1f')  
  }
  formatz2 <- function(x){
    sprintf(x, fmt = '%#.2f')  
  }
  formatz00 <- function(x){
    round(x,0) 
  }
  formatz3 <- function(x){
    sprintf(x, fmt = '%#.3f')  
  }
  formatz4 <- function(x){
    sprintf(x, fmt = '%#.4f')  
  }
  
  
  
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# function for nice upper limits to count bar plots, stack exchange
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
    roundUpNice <- function(x, nice=c(1,1.5, 2,4,5,6,8,10)) { #added 1.5 to help bar plot y scale
    if(length(x) != 1) stop("'x' must be of length 1")
    10^floor(log10(x)) * nice[[which(x <= 10^floor(log10(x)) * nice)[[1]]]]
  }
  
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define the Negative Binomial probability density function, with parameters
# mu and alpha. The mean of this NB distribution is mu, and variance is sigma^2=mu+alpha*mu^2
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
   e_dnbinom=function(x,mu,alpha){
     
    k = 1/alpha
    s1 = lgamma(k+x)-lgamma(k)-lgamma(x+1)    # lgamma is log(gamma)
    s2 = x*log(mu/(mu+k))
    s3 = -k*log(1+mu/k)
    prob = exp(s1+s2+s3)
    prob[x<0] = 0
    prob[prob>1] = 1
    prob[prob<0] = 0
    return(prob)
    
  }

# check
# dnbinom(   1, size=2,   mu=3)
# e_dnbinom(1, alpha=1/2,mu=3)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# This function translates the mu and alpha parameters into size and prob
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
  e_rnbinom=function(n,mu,alpha){
    size = 1/alpha          # so now we can just enter alpha this is converted to 1/ alpha
    prob = size/(mu+size)   # so now we can enter mu the mean and that is converted to prob
    return(rnbinom(n,size=size,prob=prob))
  }

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
   e_nb=function(mu,alpha){
     size = 1/alpha          # so now we can just enter alpha this is converted to 1/ alpha
     prob = size/(mu+size)   # so now we can enter mu the mean and that is converted to prob
     return(list(prob=prob,size=size))
   }
   
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # here is where prob and size are converted to mu and alpha
  #https://geek-questions.imtqy.com/articles/1785935/index.html
   rev_nb=function(prob,size){
    alpha = 1/size          # so now we can just enter alpha this is converted to 1/ alpha
    mu = size/prob - size    # so now we can enter mu the mean and that is converted to prob
    return(list(mu=mu, alpha=alpha))
   }
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
    x <- e_nb(mu=15, alpha=1.2)
    x
    rev_nb(size=x$size, prob=x$prob)
    # 
    # x<-10
    # k = 1.2
    # mu = 15
    # 
    # p = k/(k+mu)   #1
    # s = mu*p/(1-p) #2
    # 
    # dnbinom(x,size=s,prob=p)
    # dnbinom(x,mu=mu,size=k)
    #  
    # mu <- ( k/p - k )     

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# number of successes function to simulate neg binomial simulation
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
 foo <- function(p = 0.5, s = 4) { # p prob of success; s 
  
  i <- 0 # count of how many attempt we need to get s successes
  x <- 0 # use this to know when to stop function
  
  while ( x < s) {  # stop when x equals s 
    
    i <- i + 1  # count every attempt
    
    res <-  rbinom(1, size=1, prob=p)  # a la coin flip, heads is success
    
    if (res ==1) {x=x+1}   # if heads count , if not we fail
   
  }
  return(i) # result captured here
}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# start of app
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

```

Column {.sidebar}
-----------------------------------------------------------------------

**Count data analysis is explored**

```{r tab1}

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

  sliderInput('mu', 'Top panels \u03BC', value=3,
                min = 1, max = 25, step=.5, ticks=F)
  
  sliderInput('alpha_a', 'Top panels \u03B1', value = c(1/3),
                min = 0, max = 5 ,step=0.01, ticks=F)
 
  sliderInput('P', 'Probability of Success (bottom panels)', value=.5,
                min = 0.01, max = 1, step=.01, ticks=F)
  
  sliderInput('s', 'No of successess (bottom panels)', value = c(3),
                min = 1, max = 200 ,step=1, ticks=F)
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
  
  sliderInput('sims', 'Simulations (bottom left panel)', 15000,
                min = 1000, max = 20000, step=1000,ticks=F)
  
  sliderInput('x_range', 'Plot x-range', value = c(0,10),
          min = 0, max = 80,step=5,ticks=F)
  
  sliderInput('y_range', 'Plot y-range', value = c(0,.25),
          min = 0, max = 1,step=.05,ticks=F)

  checkboxInput('perc','show stats on barplot', value=TRUE)

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

```

$\alpha$ takes on positive rational values, rarely above 4. Values of $\alpha$ greater than 2 usually indicate that there is substantial over-dispersion.

When $\alpha$ approaches 0, k approaches infinity and Poisson emerges (move red $\alpha$ slider to 0).

When $\alpha$ > 1, k < 1 leads to over dispersed data.

$\alpha$ = 1/k ; k = 1/ $\alpha$ see next tab.
 

Column {data-width=400, height=300}
-----------------------------------------------------------------------
### Negative binomial couched in terms of mu and alpha


```{r tab1 plot1, eval=TRUE}

 
        renderPlot({
  
      mu = input$mu
      alpha_a = input$alpha_a
          
      low =  input$x_range[1]
      xmax=  input$x_range[2]
      ymax = input$y_range[2]

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  xx <- c(seq(0,xmax,1)) 

  if(alpha_a==0) {
    yb =    dpois(xx,mu)
  }else{
    yb=     e_dnbinom(xx,mu,alpha_a)
  }

  b <- barplot(yb, xlim=c(0,xmax+2), ylab = "Percent", xlab="Count of failed attempts (X-r)", col='lightgreen',
          ylim=c(0,ymax),
          main =  paste0("Negative Binomial \u03BC = ",mu," \u03B1 = ",formatz2(alpha_a),", variance = ", (mu+alpha_a*mu^2* alpha_a),""), # mu+alpha_a*mu^2* alpha_a
          names.arg= as.character(xx))
  
  if(input$perc) {
    x  <- 0:length(b) # % onto top of bars
    y1 <- yb + 0.02
    z  <- round(yb,2) *100
    z  <- paste0(z,"%")
    text(x=b[x+1],y=(y1),labels=z, cex = 1)
  }
})
    
 
```

### Negative binomial mu and alpha converted to probability of success and number of successful attempts  

```{r, tab1 plot2, eval=TRUE}

  renderPlot({
    
    
  sim <- input$sims
  # P <- input$P   # randomly pick a probability
  
  z <- e_nb(input$mu, input$alpha_a)
 
  P = z[1][[1]]
  s = z[2][[1]]
  
  #low =  input$x_range[1]
  xmax=  input$x_range[2]
  ymax = input$y_range[2]
 # ymin = input$y_range[1]

  
  # simulation bar plot
  #!!!!!!!!!!!!!!!!!!!!!!this is actually not used
  number_of_attempts <- replicate(sim, foo(p=P,s=s))  # run function many times
   
  Tm <-  1/P*s 
  Sm <- mean(number_of_attempts) 
  
  x <- table(factor(number_of_attempts, levels = s: max(number_of_attempts))) # pad out so levels so no counts included
   
  m = length(x)-1
  z <- (0:m)+3 # labels
  d <- dnbinom(0:m, prob=P, size=s)
  b <- barplot(d , #x/sim, 
               
               xlim=c(0,xmax+2),  
               ylim=c(0,ymax),
               main = paste0("Number of attempts until we reach ",s," successes when p=",formatz2(P),
                                    "\n True \u03BC ",formatz2(Tm) , #" ; Simulated \u03BC (green) ",formatz2(Sm) ,
                             ""),
               col="orchid1", 
               ylab="Probability of success", 
               xlab="Attempts for success (no simulation); note we can get non-integers!",
               names.arg= as.character(z))
  
  # overlay true neg binomial dist.
  #m <- length(b)-1
 
#  d <- dnbinom(0:m, prob=P, size=s) # s was 0 and ymax was m
# no need for these points and lines...
# lines( x = b, y = d , col='red')
 # points(x = b, y = d , col='red')
 
    if(input$perc) {
      
        x  <-0:length(b) # % onto top of bars
        y1 <- d + 0.02
        z  <- round(d,2) *100
        z  <- paste0(z,"%")
        text(x=b[x+1],y=(y1),labels=z, cex = 1)
}
  })

```

Column {data-width=400}
-------------------------------------

### Negative binomial couched in terms of probability of success and number of successesful attempts

```{r, tab1 plot3, eval=TRUE}
 
 renderPlot({

  sim <- input$sims
  P <- input$P   # randomly pick a probability
  if (P==0) P=0.01
  s <- input$s   # randomly pick nth success
  
  #low =  input$x_range[1]
  xmax=  input$x_range[2]
  ymax = input$y_range[2]
 # ymin = input$y_range[1]
   
  # simulation bar plot
  number_of_attempts <- replicate(sim, foo(p=P,s=s))  # run function many times
  
  #Tm <- s*(1-P)/P + s
  Tm <-  1/P*s 
  Sm <- mean(number_of_attempts) 
  
 
  x <- table(factor(number_of_attempts, levels = s: max(number_of_attempts))) # pad out so levels so no counts included
  
 # x <- table(factor(number_of_attempts, levels = s: ymax)) # pad out so levels so no counts included

  b <- barplot(x/sim, 
               
               xlim=c(0,xmax+2),  
               ylim=c(0,ymax),
               main = paste0("Number of attempts until we reach ",s," successes when p=",formatz2(P),
                                    "\n True \u03BC ",formatz2(Tm) ," ; Simulated \u03BC (lilac) ",formatz2(Sm) ,""),
                                    
               col="orchid1", 
               ylab="Probability of success", 
               xlab="Attempts for success (simulated in lilac, true negative binomial distribution red line with true %s above bars)")
  
  # overlay true neg binomial dist.
  m <- length(b)-1
 
  # d <- dnbinom(s:ymax, prob=P, size=s) # s was 0 and ymax was m
  
  d <- dnbinom(0:m, prob=P, size=s) # s was 0 and ymax was m

  lines( x = b, y = d , col='red')
  points(x = b, y = d , col='red')
 
    if(input$perc) {
      
        x  <-0:length(b) # % onto top of bars
        y1 <- d + 0.02
        z  <- round(d,2) *100
        z  <- paste0(z,"%")
        text(x=b[x+1],y=(y1),labels=z, cex = 1)
  }

 })


```

###  Negative binomial probability of success and number of successful attempts converted to mu and alpha


```{r, tab1 plot4}

    renderPlot({
  
    z <-  rev_nb(input$P, input$s)
    
    mu = z[1][[1]]
    alpha_a = z[2][[1]]
        
    low =  input$x_range[1]
    xmax=  input$x_range[2]
    ymax = input$y_range[2]

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  xx <- c(seq(0,xmax,1)) 

  if(alpha_a==0) {
    yb =    dpois(xx,mu)
  }else{
    yb=     e_dnbinom(xx,mu,alpha_a)
  }

  b <- barplot(yb, xlim=c(0,xmax+2), ylab = "Percent", xlab="Count of failed attempts (X-r)", col='lightgreen',
          ylim=c(0,ymax),
          main =  paste0("Negative Binomial \u03BC = ",mu," \u03B1 = ",formatz2(alpha_a),", variance = ", mu+alpha_a*mu^2* alpha_a,""),
          names.arg= as.character(xx))
  
  if(input$perc) {
    x  <- 0:length(b) # % onto top of bars
    y1 <- yb + 0.02
    z  <- round(yb,2) *100
    z  <- paste0(z,"%")
    text(x=b[x+1],y=(y1),labels=z, cex = 1)
  }
})

```


Probability mass functions 2
===


Column {.sidebar}
-----------------------------------------------------------------------

**xxxxxxxxxxxx**

```{r tab1x}




```

Column {data-width=400, height=300}
-----------------------------------------------------------------------
### a


```{r tab1. plot1x, eval=TRUE}

 
    
 
```

### b 

```{r, tab1 plot2x, eval=TRUE}

 

```

Column {data-width=400}
-------------------------------------

### c

```{r, tab1 plot3x, eval=TRUE}
 
 

```

###  d


```{r, tab1 plot4x}

   
```

 