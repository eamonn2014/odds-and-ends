---
title: "Method Comparison and beyond" 
author: 
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: scroll
    social: menu
    source_code: embed
runtime: shiny
---
Method Comparison
===



```{r global, include=FALSE}

  rm(list=ls())

  set.seed(64453)
  #library(MASS)      # for correlated data generation
  library(flexdashboard)
  library(ggplot2)
  library(gridExtra)
  library(ggpubr)
  library(ggExtra)
  library(shiny)
  library(utf8)      # codes for Greek letters
  library(MethComp)
  library(gridExtra)
  library(tidyverse)
  library(plyr)
  library(rms)
  lwd.=3             # used when plotting
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # function to format decimals
  # https://stackoverflow.com/questions/3245862/format-numbers-to-significant-figures-nicely-in-r
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  p3 <- function(x) {formatC(x, format="f", digits=3)}
  
  formatz <- function(x){
    
    if (!is.na(x)  ) {
      
      formatC(signif(x,digits=5), digits=5,format="fg", flag="#",big.mark=",")
      
    }
    
  }
  
  formatz0 <- function(x){
    sprintf(x, fmt = '%s')  
  }
  formatz1 <- function(x){
    sprintf(x, fmt = '%#.1f')  
  }
  formatz2 <- function(x){
    sprintf(x, fmt = '%#.2f')  
  }
  formatz00 <- function(x){
    round(x,0) 
  }
  formatz3 <- function(x){
    sprintf(x, fmt = '%#.3f')  
  }
  formatz4 <- function(x){
    sprintf(x, fmt = '%#.4f')  
  }
  
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# function to generate cor data , see count app
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

mvrnorm <- function(n = 1, mu = 0, Sigma) {
  nvars <- nrow(Sigma)
  # nvars x n matrix of Normal(0, 1)
  nmls <- matrix(rnorm(n * nvars), nrow = nvars)
  # scale and correlate Normal(0, 1), "nmls", to Normal(0, Sigma) by matrix mult
  # with lower triangular of cholesky decomp of covariance matrix
  scaled_correlated_nmls <- t(chol(Sigma)) %*% nmls
  # shift to center around mus to get goal: Normal(mu, Sigma)
  samples <- mu + scaled_correlated_nmls
  # transpose so each variable is a column, not
  # a row, to match what MASS::mvrnorm() returns
  t(samples)
}
   


 # https://stackoverflow.com/questions/6461209/how-to-round-up-to-the-nearest-10-or-100-or-x/6468532#6468532
 # nice function from link to round to selected value

  roundUp <- function(x,to=10)
  {
    to*(x%/%to + as.logical(x%%to))
  }

 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# start of app
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

```

Column {.sidebar}
-----------------------------------------------------------------------

**xxxxxxxxxxxxxxxx**

```{r tab1}

 
 
  sliderInput('n', 'n pairs of data', value=100,
                min = 5, max = 1000, step=5, ticks=F)

  sliderInput('mu0', 'Initial mean  \u03BC', value=0,
                min = -100, max = 100, step=5, ticks=F)
  
 
  sliderInput('eff.p', 'Effect of treatment', value = c(0),
                min = -25, max = 25 ,step=1, ticks=F)
  
   sliderInput('r', 'Correlation', value = c(.8),
                min = -.9, max = .9, step=0.05, ticks=F)
     
  sliderInput('sd.', 'Common SD', 1,
                min = 1, max = 100, step=1,ticks=F)
  
  selectInput("SD.type", "Select SD type", choices = c("cons", "lin"), selected="cons")
  
  selectInput("Dif.type", "Select difference type", choices = c("cons", "lin"), selected="cons")
  
  selectInput("Pl.type", "Select difference type", choices = c("BA", "conv"), selected="BA")
 
  
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   # orange button
   actionButton("resample",   "Hit to simulate a new sample")
      
   #  tags$head(
   tags$style(HTML('#resample{background-color:orange}'))
   # )
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 

```

$\alpha$ xxxxxxxxxxxxxxxxxxxx

xxxxxxxxxx $\alpha$ xxxxxxxxxxxxxxxxxxx

xxxxxxxxx $\alpha$ xxxxxxxxxxxxxxxxxxxxxxx

$\alpha$ xxxxxxxxxxxxxxxxxx 
 

Column {data-width=400, height=75}
-----------------------------------------------------------------------
### Chart 1

```{r tab1 plot1}
 
   # --------------------------------------------------------------------------
    # I looked back to two period cross over trial to get this button working to resimulate
    # This is where a new sample is instigated only random noise is required to be generated
    random.sample <- reactive({
      
    # Dummy line to trigger off button-press
    foo <- input$resample
         
    L1 <-     input$mu0
    L2 <-     input$mu0+input$eff.p
    r  <-     input$r
    n <-      input$n
    sd. <-    input$sd.
    
# generate correlated poisson ref: https://thomasward.com/simulating-correlated-data/
# Sample correlated N(0, 1) distributions from a multivariate normal distribution.
# Transform them to correlated Uniform(0, 1) distributions with the normal CDF.
# Transform them to any correlated probability distribution you desire with that probability distributionâ€™s inverse CDF.

    Sigma <- matrix(c(1, r, r, 1), 2, 2)

    px <- mvrnorm(n, Sigma = Sigma)   # correlated continuous, see function in global area!

    U <- pnorm(px, mean = 0, sd = 1)  # correlated uniform
    
    pp1 <- qnorm(U[, 1], L1, sd.)      # correlated normal  
    pp2 <- qnorm(U[, 2], L2, sd.) 
        
    return(list(pp1=pp1, pp2=pp2, sd.=sd.))
     })
   
    # --------------------------------------------------------------------------


  r1 <- reactive({
 
    sample <- random.sample()
     
     r  <-     input$r
     n <-      input$n
     sd. <-    sample$sd.  
 
     pp1 <- sample$pp1     # correlated normal  
     pp2 <- sample$pp2 
    
    cor. <- cor(pp1, pp2)              # capture correlation
 
    # create a data frame
    my_data <- data.frame( 
      group = rep(c("A.before", "B.after"), each = n),
      counts = c(pp1,  pp2),
      ID=rep(1:n,2)
    )

    ## variance of a difference from a simulation
    est <- var(pp1) + var(pp2) - 2 *cor. * sd(pp1) * sd(pp2)
    
    ## true variance of difference
    true <- sd.^2 + sd.^2 - 2 * r * sd. * sd.
    
    ## variance of a sum
    # var(pp1) + var(pp2) + 2 *cor. * sd(pp1) * sd(pp2)
    # 
    # 
    # sd.^2 +sd.^2 + 2 * r * sd.*sd.

 return(list( est=est, true=true , pp1=pp1, pp2=pp2 ))
     
  })
  
  # --------------------------------------------------------------------------
  h5(htmlOutput("text3"))      ## print 
  
```


```{r, test}
   # --------------------------------------------------------------------------
   # https://stackoverflow.com/questions/63507171/shiny-increase-mathjaxs-font-size
   # help on font size
   h5(htmlOutput("text2"))      
   # --------------------------------------------------------------------------
                              withMathJax(
                                tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
                             helpText('
                             $${  
                             {\\sigma^2}{_{x \\pm y}} =  
                             {\\sigma^2}{_{x}}  +   {\\sigma^2}{_{y}} 
                             \\pm 2\\rho{\\sigma}{_{x}} {\\sigma}{_{y}}           
                             }\\!$$'
                             ))   
                             )
    # --------------------------------------------------------------------------
   h5(htmlOutput("text2a"))   
     
                            withMathJax(
                               tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
                             helpText('
                              $${ 
                              \\rho {\\sigma}{_{x}}  {\\sigma}{_{y}}           
                              }\\!$$'))        
  
                            )
    # --------------------------------------------------------------------------
    h5(htmlOutput("text4"))   
    # --------------------------------------------------------------------------
```

 
```{r } 

  # --------------------------------------------------------------------------
output$text2 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "If the variables are uncorrelated the variance of the difference is equal to the sum of the variances. If there is any correlation this information is incorporated: ")))
  
})
  # --------------------------------------------------------------------------

output$text2a <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "The following is the covariance between the two variables. We add 2 x this if we are interested in the variance of the sum, for the variance of the difference we subtract 2 x this component. ")))
  
})
   # --------------------------------------------------------------------------
   

output$text3 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "A method comparison with ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", input$n) ,
   
     tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               " samples assayed on each of two methods. There is a true bias of ") 
      
      , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", input$eff.p) ,
     
     
        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
     
    ", also there is a true correlation between the paired results of ")
    
      , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", input$r) ,
    
    
        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
    
    " and between sample sd commmon to both methods of ")
    
      , tags$span(style="color:blue ;font-weight:bold;font-size: 20px;", input$sd.) ,
    
     tags$span(style="color:black;font-weight:bold;font-size: 20px;",
               
    ". By design the SD is constant across the range of values. There are no technical replicates ", #),
    
    
        ".") ))
  # --------------------------------------------------------------------------
 })
 

output$text4 <- renderText({  # create interactive text t1

    print(paste0(   

        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "Based on the true parameters, the variance of the difference is ") 
    
         , tags$span(style="color:blue ;font-weight:bold;font-size: 20px;",formatz3( r1()$true )),
                     
                     tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
    
     ", this equates to an SD of the differences of ") 
    
       , tags$span(style="color:blue ;font-weight:bold;font-size: 20px;", formatz3(sqrt(r1()$true))) ,
    
     tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               ". The estimate from a simulated experiment is ") 
    
     , tags$span(style="color:blue ;font-weight:bold;font-size: 20px;", formatz3( r1()$est )),
                 
                  tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
    
        ", this equates to an SD of the differences of ")
    
     , tags$span(style="color:blue ;font-weight:bold;font-size: 20px;", formatz3( sqrt(r1()$est)),
    
        ".") ))

 })
  # --------------------------------------------------------------------------

# see line 1412
output$text5 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "The contrast of ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", inference()$i )
    
     , tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               " versus ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", inference()$j )
    
       , tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               " is estimated as ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", formatz3(inference()$res)) ,
   
     tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               " with confidence interval ( ") 
      
      , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", formatz3(inference()$L)) ,
     
     
        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
     
    ",  ")
    
      , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", formatz3(inference()$H) ),
    
    
       tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
    
    " ) ")#,
    
     # , tags$span(style="color:blue ;font-weight:bold;font-size: 20px;", input$sd. ),
    
    # tags$span(style="color:black;font-weight:bold;font-size: 20px;",
               
  #  ". xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx ", #),
    
    
  #      ".")
  ))
})

 

``` 


Column {data-width=400}
-------------------------------------

### Chart 3

```{r, tab1 plot3}

   # --------------------------------------------------------------------------
 

renderPlot({
  
  A <- r1()$pp1
  B <- r1()$pp2
  
  m <- ceiling(max(A,B))
  mL <- floor(min(A,B))
  before <- A  
  after <-  B  
  n <- length(before)
  d <- data.frame(y = c(before, after), 
                  x = rep(c(1,2), each=n),
                  id = factor(rep(1:n,2)))
  
  d$xj <- jitter(d$x, amount=.13)
  # code from count app
  AA <- ggplot(data=d, aes(y=y) ) +
    geom_boxplot(aes(x=x, group=x), width=0.2, outlier.shape = NA, col='blue', fill='lightblue') +
    geom_line(aes(x=xj, group=id),  colour='pink', alpha=.5) +
    geom_point(aes(x=xj), size=2) +
    xlab("Phase") + ylab("Count") +  
    scale_x_continuous(breaks=c(1,2), labels=c("Before", "After"), limits=c(0.5, 2.5)) +
   # scale_y_continuous(breaks=c(mL:m), limits=c(mL,m)) +
    theme_bw() + theme(legend.position = "none") 
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ scatter plot
  

  d <- data.frame(y = B , x = A)
  
  BB <- ggplot(d, aes(x, y)) +
    geom_jitter(width = 0.1, height = 0.1, size=2) +
   # scale_x_continuous(breaks=c(0:m), limits=c(mL,m)) +
   # scale_y_continuous(breaks=c(0:m), limits=c(mL,m)) +
    scale_x_continuous( limits=c(mL,m)) +
    scale_y_continuous(  limits=c(mL,m)) +
    xlab("Before count") +ylab("After count") +
    theme_bw() + theme(legend.position = "none") +
    geom_abline(intercept=0, slope=1)
  
  plot1 <- AA
  plot2 <- BB
  grid.arrange(plot1, plot2, ncol=2)


})
  # --------------------------------------------------------------------------


```

### Chart 4

```{r, tab1 plot4}

    
  # --------------------------------------------------------------------------


renderPlot({
  
    A <- r1()$pp1
    B <- r1()$pp2
    n <- input$n
    
    d <- data.frame(y = A , x = B)
  
    my_data <- data.frame( 
      group = rep(c("before", "after"), each = n),
      counts = c(d[,1],  d[,2]),
      ID=rep(1:n,2)
    )
  
   m <- Meth(my_data,meth="group",item="ID",repl=NULL,y="counts",print=TRUE)
   
   L <- max(abs(floor(min(A-B))),abs(ceiling(max(A-B))))
   
   L <- roundUp(L)
    
    # we set up const dif and const sd so that will matches true data genrting mechanism
    par( mfrow=c(1,1), mar=c(3,3,1,3), mgp=c(3,1,0)/1.6 )
   
    BA.plot( m, model=NULL, repl.conn=TRUE, col.lines="blue",
             # axlim=c(0,20), 
             diflim=c(-L,L), 
             xaxs="i", yaxs="i",
             las=1, eqn=TRUE,  
             pl.type=input$Pl.type, 
             sd.type=input$SD.type, 
             dif.type = input$Dif.type, # cons is simulatied
             grid=1:9*10, digits=3,font.eqn=1  , eqax=T)

})

  # --------------------------------------------------------------------------
 
```


tab2 $\alpha$
====

```{r, k or A}
  

```

```{r syntax, eval=TRUE, echo=TRUE}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# End
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

```
 
Diagnostics
====

<!-- Column {.sidebar} -->
<!-- ----------------------------------------------------------------------- -->


```{r gammapoisson}

                                
    # sliderInput('N.pg', 'Patients per arm', value=1000,
    #               min = 1000, max = 100000, step=5, ticks=F)
    # 
    # sliderInput('mu0.pg', 'Placebo event rate \u03BC per patient yr of follow up', value=1,
    #               min = 0.1, max = 25, step=.05, ticks=F)
    # 
    # sliderInput('eff.pg', 'Hypothesised treatment effect ', value=.75,  # 1/2 ing to doubling
    #               min = 0.5, max = 2, step=.05, ticks=F)
    # 
    # sliderInput('k.pg', 'This needs to be \u03B1 the heterogeneity (ancillary) parameter. \u03B1 = 1/k', value = 1.3 ,  
    #               min = 0, max = 5 ,step=0.01, ticks=F)
    # 
    # sliderInput('d1.pg', 'Placebo discontinuation prob', value = c(0.1),
    #               min = 0, max = .5 ,step=0.05, ticks=F)
    # 
    # sliderInput('d2.pg', 'Treatment discontinuation prob', value = c(0.1),
    #               min = 0, max = .5 ,step=0.05, ticks=F)
    # 
    # sliderInput('fup.pg', 'Follow up (yrs)', value = c(1),
    #         min = 1, max = 10, step=1,ticks=F)

```

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 
 

Column {data-width=400, height=300}
-----------------------------------------------------------------------

### Constant SD assumption

```{r, gp barplots, eval=TRUE}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 
  r2 <- reactive({
 
    L1 <-     input$mu0
    L2 <-     input$mu0+input$eff.p
    r  <-     input$r
    n <-      input$n
    sd. <-    input$sd.
    

    A <- r1()$pp1
    B <- r1()$pp2
    n <- input$n
    
    d <- data.frame(y = A , x = B)
    
    my_data <- data.frame( 
      group = rep(c("before", "after"), each = n),
      counts = c(d[,1],  d[,2]),
      ID=rep(1:n,2)
    )
    
    m <- Meth(my_data,meth="group",item="ID",repl=NULL,y="counts",print=TRUE)
     
 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # code from my useful code, adjusted slightly

  BA <- DA.reg(m, DA.slope = TRUE)

  a1<-as.data.frame(unlist(BA))
  #DA.slope.p<-a1[14,]
  #cons.sd.p.value<-a1[38,]
  
  res<-rbind(a1[14,], a1[38,])
  res<-as.matrix(res)
  
  rownames(res)<-c( 
                   "DA Slope P-value",
                   "P-value for Changing SD")
  
  colnames(res) <- c("Bland Altman Analysis")
 # print(res)

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ## **Assess Bland Altman assumptions P-values for two hypotheses:**
  w <- to.wide(m)
  ## assumptions do it yourself

  w$y <- w$before - w$after
  w$y <- w$after - w$before
  
  w$x <-  (w$before + w$after) /2
  
  # Constant difference - this is the test of 0 slope in the regression of differences on averages.
  f <- summary(lm(y~x, w))
  con.diff <- f$coefficients["x","Pr(>|t|)"]
  
  
  # Constant variance - this is the test of 0 slope in the regression of absolute residuals on averages.
  w$r <- abs(residuals(f) ) # if you dont use abs the regression line slope will be 0!
 # w$r <- (residuals(f) )
  #plot(r~x,w)
  f1 <- summary(lm(r~x, w))
  con.sd <- f1$coefficients["x","Pr(>|t|)"]
  
  ##
  # . A formal test of increasing or
  # decreasing variance by the level of measurement can be obtained by
  # first regressing the differences on the averages and then regressing the
  # absolute residuals from this on the averages 
  # 
  # library(ggplot2)
  # library(ggpubr)
  # ggplot(w, aes(x=x, y=r))+
  #   geom_point() +  
  #   geom_smooth(method="lm", col="black")  +
  #   stat_regline_equation(label.x = min(w$x), label.y = max(w$r))+
  #   theme_bw() +
  #   labs(title = paste0("Regression of absolute residuals on averages, p=", assump2),
  #        x = "Averages",
  #        y = "Absolute residuals")
   
  return(list( con.diff=con.diff, con.sd=con.sd , w=w ))
  

})

renderPlot({
  
w <- r2()$w
con.sd <- r2()$con.sd
  
  ggplot(w, aes(x=x, y=r))+
    geom_point() +  
    geom_smooth(method="lm", col="black")  +
    stat_regline_equation(label.x = min(w$x), label.y = max(w$r))+
    theme_bw() +
    labs(title = paste0("First regressing the differences on the averages and then regressing the absolute residuals from this on the averages.\nTesting hypothesis slope=0, p=", formatz3(con.sd)),
         x = "Averages",
         y = "Absolute residuals")
   
})

 

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``` 

### Constant difference assumption

```{r nb barplots, eval=TRUE}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
renderPlot({
  
w <- r2()$w
con.diff <- r2()$con.diff
 

  ggplot(w, aes(x=x, y=y))+
    geom_point() +  
    geom_smooth(method="lm", col="black")  +
    stat_regline_equation(label.x = min(w$x), label.y = max(w$r))+
    theme_bw() +
    labs(title = paste0("Regression of differences on averages.\nTesting hypothesis slope=0, p=", formatz3(con.diff)),
         x = "Averages",
         y = "After - before")

})
 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


```
   
Column {.tabset .tabset-fade}
-----------------------------------------------------------------------

### Constant difference assumption
  

```{r diagnostics1, eval=TRUE}

renderPlot({
  
  w <- r2()$w
  con.diff <- r2()$con.diff
  
  mod1 <- lm(y ~ x, data = w) 
  w$pred = predict(mod1)  
  
  p <- w %>%
    ggplot(aes(x = x, y = y) ) +
    geom_point(pch = 21, color = "white", fill = "black", size = 2, alpha = 0.8) +
    geom_smooth(method = "lm", colour = "black", se=TRUE, level=.95, fill="cornflowerblue") +
    stat_regline_equation(label.x = min(w$x), label.y = max(w$y))+
    
     labs(title = 
    paste0("Regression of differences on averages. Testing hypothesis slope=0, p=", formatz3(con.diff)),
         x = "Averages",
         y = "After - before") +

    geom_segment(
      aes(xend = x, yend = pred),
      size = 0.5, alpha = 0.8, lineend = "round", col="pink"
    ) +
    
    theme_bw(base_size = 12)
  
    ggMarginal(p, type = "histogram", bins = 50)

})


```

###  Constant variance assumption
 
```{r diagnostics2}

# x averages
# y differences
# r abs residuals

renderPlot({
  
w <- r2()$w

  con.sd <- r2()$con.sd
  
  f <- summary(lm(y~x, w)) # First regressing the differences on the averages 
  w$r <- abs(residuals(f) ) 
  mod1 <- lm(r ~ x , data = w) # regressing the absolute residuals from this on the averages
  
  w$pred = predict(mod1) # pred and fitted no dif with linear model
 # w$pred = fitted(mod1) 

p1 <-  ggplot(w, aes(x=x, y=r))+
    geom_point(pch = 21, color = "white", fill = "black", size = 2, alpha = 0.8) +
    geom_smooth(method = "lm", colour = "red", se=TRUE, level=.95, fill="#69b3a2") +
     stat_regline_equation(label.x = min(w$x), label.y = max(w$r))+
    theme_bw() +
    labs(title = paste0("First regressing the differences on the averages and then regressing the absolute residuals from this on the averages. Testing hypothesis slope=0, p=", formatz3(con.sd)),
         x = "Averages",
         y = "Absolute residuals") +
    
    geom_segment(
      aes(xend = x, yend = pred),   ## trying to join to reg line
      size = 0.5, alpha = 0.8, lineend = "round", col="pink"
    ) +
    
    theme_bw(base_size = 12)

  ggMarginal(p1, type = "histogram", bins = 50)

})
  

```

### histogram of differences
  

```{r diagnostics3, eval=TRUE}
 
# https://statisticsglobe.com/normal-density-curve-on-top-of-histogram-ggplot2-r
# calculate mean and sd by group
# stats <- aggregate(y~1, w, function(x) c(mean=mean(x), sd=sd(x)))
 

renderPlot({
  
w <- r2()$w

  df <- w
  
  argz1 <- c(   mean(df$y),   input$eff.p)
  argz2 <- c(   sd(df$y),     sqrt(r1()$true) )
  colz <-  c("black", "red")
  
  xv <- argz1[2]+1.2

 p <- ggplot(df, aes(y)) +      
  
  geom_histogram(aes(y = ..density..),
                 colour = "white", fill = "cornflowerblue", size = 0.1) +
 
   theme_bw() +
  
  annotate("text",  x=xv, y=.8, label= paste0("Estimated Mean differences = ", formatz3(mean(df$y))," and SD of differences = ",          formatz3(sd(df$y)), " (black)"))  +
  annotate("text",  x=xv, y=.7, label= paste0("True Mean difference = ",      formatz3( input$eff.p),", and true SD of differences = " ,  formatz3(sqrt(r1()$true)) ,  " (red)"))
  
# https://stackoverflow.com/questions/2237600/how-can-i-plot-multiple-functions-in-r
 # adding density plots
 for(i in 1:2)
   
    p <- p +  stat_function(fun = dnorm,
                args = list( mean = argz1[i], sd = argz2[i] ),
                col = colz[i],
                size = 1.5)
    print(p)

})


 
```

### xxxxxxxxxxxxxxx 
 
 
```{r diagnostics4}

  
```

### xxxxxxxxxxxxxxx
 
 
```{r diagnostics5}

   

```

### xxxxxxxxxxxxx

```{r diagnostics6, eval=TRUE}

  
``` 
 

T-test 
====

Column {.sidebar}
-----------------------------------------------------------------------

Here we define the parameters of a lognormal distribution and a proportional change

```{r, main power tab2}
 
    
      div(h5(tags$span(style="color:blue", "Enter True Population values:")))
                                  
      textInput("v1", div(h5(tags$span(style="color:blue", "Log Normal mean"))),     value= "100")
      textInput("v2", div(h5(tags$span(style="color:blue", "Log Normal SD)"))),      value= "50")
      textInput("v3", div(h5(tags$span(style="color:blue", "Sample in 1 arm"))),     value= "60")
      textInput("v4", div(h5(tags$span(style="color:blue", "Confidence Level"))),    value= "0.90")
      textInput("v5", div(h5(tags$span(style="color:blue", "QC Level"))),            value= "0.85")
      textInput("v6", div(h5(tags$span(style="color:blue", "Proportional change"))), value= "0.95")
       
# try these means and sds
# 0.3  0.08
# 0.19 0.15 
# 0.42 0.32
# 0.96 0.1
# 0.9  0.09

```


```{r text power, eval=TRUE}


  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  random.sample2 <- reactive({

    foo <- input$resample
    
    # writing like this I can write log and fraction into input boxes!
    mux  <- as.numeric(    eval(parse(text= (input$v1)) ) )
    a    <- as.numeric(    eval(parse(text= (input$v2)) ) )
    n    <- as.numeric(    eval(parse(text= (input$v3)) ) )
    conf <- as.numeric(    eval(parse(text= (input$v4)) ) )
    qc   <- as.numeric(    eval(parse(text= (input$v5)) ) )
    zx   <- as.numeric(    eval(parse(text= (input$v6)) ) )
    #normal_to_lognormal(normmean = mux, normsd = a)
    
    v <- a^2
    m <- mux
    
    phi = sqrt(v + m^2);
    mu    = log(m^2/phi)          # mean of log(Y)     
    sigma = sqrt(log(phi^2/m^2))   # std dev of log(Y)  
      
    # feed normal distirbution parameters into this function:
    zz <- power.t.test(n=n, delta =log(zx), sd=sigma, sig.level=0.05,
                      # power=pow,
                       type="two.sample", alternative=c("two.sided"))
    
     
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # this duplicates my code
    #lognormal_to_normal(meanlog=mu, sdlog=sigma)
    
    v <- sigma^2
    logN.mu <- exp(mu+0.5* v)
    logN.SD <- logN.mu*sqrt(exp(v)-1)
    
    #------------------------------------------------------------------------------
    
    N <- ceiling(zz$n)
    sd    <- sigma
    delta <- log(zx)
    
    A <- lapply(1:N, function(i) rlnorm(1, meanlog=mu,       sdlog=sd))
    B <- lapply(1:N, function(i) rlnorm(1, meanlog=mu+delta, sdlog=sd))
    
    A <- unlist(A)
    B <- unlist(B)
    
    A.GM <- exp(mean(log(A)))
    B.GM <- exp(mean(log(B)))
    
    #------------------------------------------------------------------------------
        return(list(
          
         mu=mu, sd=sd, zz=zz, logN.mu=logN.mu, logN.SD=logN.SD, 
         delta=delta, A.GM=A.GM, B.GM=B.GM, zx=zx, A=A, B=B, N=N, conf=conf, qc=qc,  mux=mux
    
        ))
      })

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
  

```
 

Column {data-width=400, height=75}
-----------------------------------------------------------------------
 
   
### xxxxxxxxxxxxxxxxxx

```{r power typical barplot}

renderPlot({
  
  
  N <-  random.sample2()$N
  mu <-  random.sample2()$mu
  mux <-  random.sample2()$mux
  logN.mu <-  random.sample2()$logN.mu
  logN.SD<-  random.sample2()$logN.SD
  zx<-  random.sample2()$zx
  sd<-  random.sample2()$sd
 
  A<-  random.sample2()$A
  B<-  random.sample2()$B#
  A.GM<-  random.sample2()$A.GM
  B.GM<-  random.sample2()$B.GM
 
  delta <-  random.sample2()$delta
 
  
  
  
  
    par(mfrow=c(2,2))
    
    x<-seq(-8+mu,+8+mu,by=0.02) # range of values to plot over
    
    br <- ifelse(N<100, N, 100) # bins in histograms
    
    #~~~~~~~~~~~~~~~~~~~
    MASS::truehist(A, 
                  yaxt='n' ,
                  nbins=br,  axes=FALSE,
                   main=paste0("A. N=",N," realisations from log-normal mu=",p3(logN.mu),", SD=",p3(logN.SD),", Geometric Mean=",p3(A.GM)), col = "blue", 
                  border = "white", xlab="Original scale")
    
    curve(dlnorm(x, meanlog = mu, sdlog =sd, log = FALSE), add=TRUE)   #adding log normal curve, here the mean and sd of the transformed dist are entered
    Axis(side=1, labels=TRUE)
    Axis(side=2, labels=FALSE)
    
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    MASS::truehist(log(A), yaxt='n' , nbins=br,  axes=FALSE,
                   main=paste0("A. N=",N," log transformed of left data, theoretical mu=",p3(mu),", SD=", p3(sd),""), col = "blue", border = "white",  xlab="log scale")
    curve(dnorm(x,mu,sd), add=TRUE)           #adding normal curve, here the mean and sd of the transformed dist are entered, as above, just dist differs
    Axis(side=1, labels=TRUE)
    Axis(side=2, labels=FALSE)
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    MASS::truehist(B, 
                    yaxt='n' ,
                    nbins=br,  axes=FALSE,
                   main=paste0("B. N=",N," realisations true log-normal mu=",mux*zx,", SD=", p3(logN.SD),", Geometric Mean=",p3(B.GM) ,"\nTreatment effect ",mux*zx," / ",mux,"=",zx), 
                   col = "orange", border = "white", xlab="Original scale")
     
    curve(dlnorm(x, meanlog = mu+delta, sdlog =sd, log = FALSE), add=TRUE)  
    Axis(side=1, labels=TRUE)
    Axis(side=2, labels=FALSE)
    
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    MASS::truehist(log(B), yaxt='n' , nbins=br, axes=FALSE, 
                   main=paste0("B. N=",N," log transformed of left data, theoretical mu=",p3(mu+delta),", SD=",p3(sd),"\nTreatment effect ", p3(mu+delta)," - ",p3(mu),"=",
                               p3(log(zx))), col = "orange", border = "white", xlab="log scale" )
    curve(dnorm(x,mu+delta,sd), add=TRUE)
    Axis(side=1, labels=TRUE)
    Axis(side=2, labels=FALSE)
    
    par(mfrow=c(1,1))


})

 
```

Column {data-width=400}
-------------------------------------

### tabz
  
```{r}  
  
  renderPlot({
  
    
  N <-  random.sample2()$N
  mu <-  random.sample2()$mu
  mux <-  random.sample2()$mux
  logN.mu <-  random.sample2()$logN.mu
  logN.SD<-  random.sample2()$logN.SD
  zx<-  random.sample2()$zx
  sd<-  random.sample2()$sd
 
  A<-  random.sample2()$A
  B<-  random.sample2()$B#
  A.GM<-  random.sample2()$A.GM
  B.GM<-  random.sample2()$B.GM
 
 
  delta <-  random.sample2()$delta
 
  conf    <- random.sample2()$conf
  qclevel <- random.sample2()$qc

  d <- data.frame(x =c(rep( "A" , N), rep( "B" , N)), y=c(A,B))
  
  res <- t.test(log(d$y)~d$x, var.equal = TRUE, conf.level=conf) # t test
  
  ci <- exp(-res$conf.int)
  hi <- round(ci[1],3)
  lo <- round(ci[2],3)
  
  qc <- ifelse(((qclevel<=lo) && (hi<=1/qclevel)), paste0("PASS spec. of ", qclevel), paste0("FAIL spec. of ", qclevel))
  GmeanR <- round(exp(res$estimate[1]),3) # geometric means
  GmeanT <- round(exp(res$estimate[2]),3) # geometric means
  
  # %CV get the sd of the logged data and exponenitate
  cv1 <-exp(tapply(log(d$y), d$x, sd))
  GmeanRcv <-  round((((cv1[1])-1)*100),3)
  GmeanTcv <-  round((((cv1[2])-1)*100),3)
  
  ratio. <- exp( (res$estimate)[2] - (res$estimate)[1])
  ratio. <- round(ratio.,3)
  
 # run a ggplot 
  d$Y <-  (d$y)  # choose response

gx <- ggplot(d, aes(x=x, y=Y)) +
  
  geom_point(aes(fill=x), size=3, shape=21, colour="grey20",
             position =position_jitter(width=.22, height=0))+
  
  geom_boxplot(outlier.colour=NA, fill=NA,colour="grey20") +
  
  
  scale_fill_manual(values = c(A = 'blue', 
                               B = 'orange')) + 
  scale_colour_manual(values = c(A = 'blue', 
                               B = 'orange'))+
  
  labs(title=paste0("QC=", qc)) + xlab("") + ylab("score") +
  labs(subtitle = 
         paste0("Geometric mean A=" ,GmeanR,"; %CV=",GmeanRcv,
                "\nGeometric mean B=" ,GmeanT,"; %CV=",GmeanTcv,
                "\nRatio B/A " ,ratio.,", ",conf*100,"%CI (",lo,", ",hi,")")) +
  
  annotate("text", x=0.5, y=max(d$y), label=paste0("n=", table(d$x)[1][[1]])) +
  annotate("text", x=1.5, y=max(d$y), label=paste0("n=", table(d$x)[2][[1]]))    +
  theme(legend.position="none") +
  guides(fill="none") +
  theme_bw() 
 
  print(gx)

  })
 
```
  

```{r pairyed boxplot, eval=TRUE}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


```

### Plot of original data (true lognormal)

```{r BApylot}

  renderPlot({
  
    
  N <-  random.sample2()$N
  mu <-  random.sample2()$mu
  mux <-  random.sample2()$mux
  logN.mu <-  random.sample2()$logN.mu
  logN.SD<-  random.sample2()$logN.SD
  zx<-  random.sample2()$zx
  sd<-  random.sample2()$sd
 
  A<-  random.sample2()$A
  B<-  random.sample2()$B#
  A.GM<-  random.sample2()$A.GM
  B.GM<-  random.sample2()$B.GM
 
 
  delta <-  random.sample2()$delta
 
  conf    <- random.sample2()$conf
  qclevel <- random.sample2()$qc
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##### log the response and use exponentiated ticks
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  d <- data.frame(x =c(rep( "A" , N), rep( "B" , N)), y=c(A,B))
  res <- t.test(log(d$y)~d$x, var.equal = TRUE, conf.level=conf) # t test

  ci <- exp(-res$conf.int)
  hi <- round(ci[1],3)
  lo <- round(ci[2],3)
  qc <- ifelse(((qclevel<=lo) && (hi<=1/qclevel)), paste0("PASS spec. of ", qclevel), paste0("FAIL spec. of ", qclevel))
  GmeanR <- round(exp(res$estimate[1]),3) # geometric means
  GmeanT <- round(exp(res$estimate[2]),3) # geometric means

  # %CV get the sd of the logged data and exponenitate
  cv1 <-exp(tapply(log(d$y), d$x, sd))
  GmeanRcv <-  round((((cv1[1])-1)*100),3)
  GmeanTcv <-  round((((cv1[2])-1)*100),3)

  ratio. <- exp( (res$estimate)[2] - (res$estimate)[1])
  ratio. <- round(ratio.,3)
 
   # now use the tick info on ggplot of log response
   d$Y <-  log(d$y)  # choose response
 
   # choose appropriate scale next scale bigger than max d$y
   scalez <- c(0.001, 0.01, .1 ,1, 10, 100, 1000, 10000, 1e5 , 1e6)
   top <-    min(which( max(d$y) < scalez))
   bottom <- max(which( min(d$y) > scalez))
   scalez <- scalez[bottom:top]
   
   ticks= log(scalez)
 
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   
   labs <- exp(ticks)  # exponentiate the labels
   
   g1 <- ggplot(d, aes(x=x, y=Y)) +
     geom_point(aes(fill=x), size=3, shape=21, colour="grey20",
                position =position_jitter(width=.22, height=0))+
     geom_boxplot(outlier.colour=NA, fill=NA,colour="grey20") +
  
       scale_fill_manual(values = c(A = 'blue', 
                               B = 'orange')) + 
  scale_colour_manual(values = c(A = 'blue', 
                               B = 'orange'))+
  
    scale_y_continuous(
      
     limits=c(   ticks[1],  ticks[length(ticks)]  ), 
        breaks= ticks,    # this is where the values go
        labels= labs) +   # these are labels
     
     labs(title=paste0("QC=", qc)) + xlab("") + ylab("score") +
     labs(subtitle = 
            paste0("Geometric mean A=" ,GmeanR,"; %CV=",GmeanRcv,
                   "\nGeometric mean B=" ,GmeanT,"; %CV=",GmeanTcv,
                   "\nRatio B/A " ,ratio.,", ",conf*100,"%CI (",lo,", ",hi,")")) +
     
     annotate("text", x=0.5, y=max(ticks), label=paste0("n=", table(d$x)[1][[1]])) +
     annotate("text", x=1.5, y=max(ticks), label=paste0("n=", table(d$x)[2][[1]]))    +
     theme(legend.position="none") +
     guides(fill="none") +
     theme_bw() 
   
   print(g1)
   
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   
    
  })
  
``` 

Anova (linear model)
====
  
Column {.sidebar}
-----------------------------------------------------------------------
  
**xxxxxxxxxxxxxxxx**

 
```{r}

      sliderInput("range1", 
                   "Select group sizes: randomly select using range or uniquely select:", 
                    min = 2, max = 5000, value = c(100, 100), ticks=FALSE) 
                            
      sliderInput("range2", 
                  "Select lognormal baseline group mean",  
                  min = 0.5, max = 40000, value = c(400),ticks=FALSE)
                            
      sliderInput("range3", 
    "Select true group standard deviations: randomly select using range or uniquely select", 
                  min = 20, max = 10000, value = c(1000, 1000), ticks=FALSE) 
      
      textInput("pr1", div(h5(tags$span(style="color:blue", "Prop Chg Grp B v Grp A"))), value= "0.90")
      textInput("pr2", div(h5(tags$span(style="color:blue", "Prop Chg Grp C v Grp A"))), value= "0.90")
      textInput("pr3", div(h5(tags$span(style="color:blue", "Prop Chg Grp D v Grp A"))), value= "1.00")
 
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   # orange button
   actionButton("resamplex",   "Hit to simulate a new sample")
      
   #  tags$head(
   tags$style(HTML('#resamplex{background-color:orange}'))
   # )
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   div(h5(tags$span(style="color:blue", "Enter a level followed by a comma and the level(s) to contrast, eg A,BCD. For example, let's evaluate this contrast,\nthe proportional change\n of B compared to A")))
   splitLayout(
    textInput("qq", div(h5(tags$span(style="color:blue", ""))), value= "B,A"),
    
    )

   
   
   output$text99 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "This the design matrix for ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", inference()$i )
    
               
  
  ))
})
   
   
   
   output$text100 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "This the design matrix for ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", inference()$j )
    
               
  
  ))
})
   
output$text101 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "This the design matrix for the subtraction ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", inference()$i ) ,

                tags$span(style="color:black;font-weight:bold;font-size: 20px;", " - ") 
  
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", inference()$j )           
    
    
  ))
     
})
   
   

    
   
   
   

```

Column {data-width=400, height=75}
-----------------------------------------------------------------------
  
### xxxxxxxxxxxxxxxxxx split this in two
  
```{r top}

 h5(htmlOutput("text5"))

renderPrint({

  model <- inference()$f
  print(model)

})

renderPrint({

  model <- inference()$x
  print(model)

})

```

 
-------------------------------------
  
### manual contrast
  
```{r left1test, eval=TRUE}  

# h5(htmlOutput("text99"))

renderPrint({

  model <- inference()$resx
  print(model)

})

 h5(htmlOutput("text99"))


renderPrint({

  model <- inference()$Xa
  print(model)

})


 h5(htmlOutput("text100"))

renderPrint({

  model <- inference()$Xb
  print(model)

})

 h5(htmlOutput("text101"))

renderPrint({

  model <- inference()$X1
  print(model)

})



renderPrint({

  model <- inference()$X2
  print(model)

})

renderPrint({

  model <- inference()$betas
  print(model)

})


renderPrint({

  model <- inference()$var.cov
  print(model)

})






random.sample3 <- reactive({
        
        # Dummy line to trigger off button-press
        foo <- input$resamplex
        
        x1 <- input$range1[1]  # size
        x2 <- input$range1[2]
        x3 <- input$range2     # mean
        x5 <- input$range3[1]  # sd
        x6 <- input$range3[2]
        
        zx1 <- as.numeric( eval(parse(text= (input$pr1)) ) )
        zx2 <- as.numeric( eval(parse(text= (input$pr2)) ) )
        zx3 <- as.numeric( eval(parse(text= (input$pr3)) ) )
         
        delta1 <- log(zx1)
        delta2 <- log(zx2)
        delta3 <- log(zx3)
         
        
        # 
        # x1 <- 40  # size
        # x2 <- 40
        # x3 <- 100     # mean
        # x5 <- 23  # sd
        # x6 <- 26
        # 
        # zx1 <- .9
        # zx2 <- .8
        # zx3 <- 1.2
        #  
        # delta1 <- log(zx1)
        # delta2 <- log(zx2)
        # delta3 <- log(zx3)
        #  
        # 
        # 
        
        
        
        
        
        top <-  4  # number of groups

    #----------------------------------------------------
    # seems that I need to use both c(x1,x2) c(x1:x2) so sample function works correctly

    if (x1==x2) {
      
      middle <-  sample(c(x1,x2),   top, replace=TRUE)    # choose top count between sliders 
      
    } else {
      
      middle <-  sample(c(x1:x2),   top, replace=TRUE)    #  
    }
    
    #----------------------------------------------------
    lower <-   x3# groups mean
    #----------------------------------------------------
    
    if (x5==x6) {
      
      replicates <-  sample(c(x5,x6),  top, replace=TRUE )   #group sds
      
    } else {
      
      replicates <-  sample(c(x5:x6),   top, replace=TRUE )   #grp sds
      
    }
    #----------------------------------------------------

# i dont like the naming of these functions!!
# try these functions https://github.com/davidski/collector/blob/main/R/fit_distributions.R

#' Given a set of parameters describing a lognormal distribution, return
#'   the parameters of the underlying normal distribution.

lognormal_to_normal <- function(meanlog, sdlog) {
  norm_mean <- exp(meanlog + sdlog^2 / 2)
  norm_sd <- sqrt( (exp(sdlog^2) - 1) * exp(2*meanlog + sdlog^2))
  list(mean = norm_mean, sd = norm_sd)
}

#' normal_to_lognormal(normmean = 20, normsd = 3)
normal_to_lognormal <- function(normmean=10, normsd=2) {
  phi <- sqrt(normsd ^ 2 + normmean ^ 2)
  lognorm_meanlog <- log(normmean ^ 2 / phi)
  lognorm_sdlog <- sqrt(log(phi ^ 2 / normmean ^ 2))
  list(meanlog = lognorm_meanlog, sdlog = lognorm_sdlog)
}


temp <- rep(lower, top)
#-----------------------------------------------------------------------

  x <- matrix(data = NA, nrow = 4, ncol = 2, byrow = FALSE,
            dimnames = NULL)
 
 #transform to normal distributions
 for( i in 1:4) {
   x[i,] <- unlist(normal_to_lognormal(normmean=temp[i], normsd=replicates[i]))
   }
  
 # get the sds
 replicates <- x[,2]  
 
 x[1,1] -> mu  # intercept
 lower <- c(mu, mu+delta1, mu+delta2, mu+delta3)  # true means

#-----------------------
 
  Nj    <- sum(middle)                        # sum each group size 
  
  muJ   <- rep(lower, times=rep(middle))      # expand means by group sizes
  
  sds   <- rep(replicates, times=rep(middle)) # expand sd by group sizes
  
  grpnames <- LETTERS[1:4]
  
  IV <- factor( rep( grpnames, times=rep(middle) ) )
  
  d <- data.frame(IV=IV,
                  mu= muJ, 
                  sd= sds,
                  x=1
  )
  
  
  d$DV = rlnorm(d$x, meanlog=d$mu, sdlog = d$sd)  # create the response
  
  df <- as.data.frame(d)
  
  dd <- arrange(df, IV)    # sort and create for better order
  
  dd$x <- NULL
  
  # ddz <<- datadist(dd) ;    options(datadist='ddz')
  # f <- ols(log(DV) ~ IV, dd)

  return(list(dd=dd ))

})



# reported in text5

inference <- reactive({
        
    df <-  random.sample3()$dd
   
    ddz <<- datadist(df) ;    options(datadist='ddz')
    f <- ols(log(DV) ~ IV, df)

    x0 <- summary(f)
    x <-  exp(x0[,4])
    # cc <- contrast(f, list(IV='B', IV='D'),
    #                   list(IV='A', IV='C'), 
    #          type='average',
    #          conf.int=.9)
    # 
    # 
    # exp(cc$Contrast)
        
   # ------------------------------------
    
    # lt <- levels(df$IV)
   qq <-    input$qq
    
   i <- gsub("^(.*?),.*", "\\1", qq)  # pull out before comma
   j <- sub('.*,\\s*', '', qq)        # pull out after comma
    
  
   #-------------------------------------------------
   
   res <- contrast(f, 
                  
       list(IV= dput(strsplit(i, "")[[1]])   ), 
       list(IV= dput(strsplit(j, "")[[1]])   ),   conf.int=0.95,  #weights=table(df$IV),
                  type='average') 
  
   des.mat <-  print(res, X=TRUE)
   
   
   
  
    estx <- exp(res$Contrast[1][[1]])
    L <-   exp(res$Lower[1][[1]])
    H <-   exp(res$Upper[1][[1]])
    # ------------------------------------
 
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # let's do the manual contrast after examining Harrell's contract.rms
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   fit =f
    
   a =  list(IV= dput(strsplit(i, "")[[1]])   )
   b =  list(IV= dput(strsplit(j, "")[[1]])   )
   
   conf.int = 0.95

    # choosing critical value either t or z 
    zcrit <- if (length(idf <- fit$df.residual)) 
      qt((1 + conf.int)/2, idf) else qnorm((1 + conf.int)/2)
  
    betas <- coef(fit)  # all model coefficients
     
    nrp <- num.intercepts(fit, "var")  # should be 1 for this simple case

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # design matrix
    pred <- function(d) {
          predict(fit, d, type = "x")
    }
    
    # left side
    da <- do.call("gendata", list(fit, factors = a, expand = TRUE)) # creates a df of levels of intrest
    xa <- pred(da)    # will give a design matrix
 
    # right side
    db <- do.call("gendata", list(fit, factors = b, expand = TRUE))
    xb <- pred(db)     # will give a design matrix
      
    ma <- nrow(xa)
    mb <- nrow(xb)
    
    mm <- max(ma, mb)

    # design matrix, removes labels
    xa <- matrix(xa, nrow = mm, ncol = ncol(xa), byrow = TRUE)
    xb <- matrix(xb, nrow = mm, ncol = ncol(xb), byrow = TRUE)
    
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # design matrix difference
    X1 <-  X <- xa - xb  # subtract   X1 will be outputted for presentation
    
    m <- nrow(X)
    
    # binding column of zeros
    if (nrp > 0)  X <- cbind(matrix(0, nrow = m, ncol = nrp), X)

    weights <- rep(1, m)          ## 1 1
    weights <- as.vector(weights)  # 1 1
    
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    X2 <- X <- matrix(    # X2 will be outputted for presentation
        apply(weights * X, 2, sum)/sum(weights), 
                  nrow = 1, dimnames = list(NULL, dimnames(X)[[2]]))
     
      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~contrast
    
      X   # [1x4]  this is the weights!   #  0  0.5   -1  0.5
      
      # weight the betas and sum to get contrast
      est <- matxv(X, betas)   # contrast!!!!!!!!!!!!!!!!!!!!!!!!  #  X %*% betas
      
      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~variance

      var.cov <- vcov(fit, regcoef.only = TRUE)   # 4X4

      v <- X %*% var.cov %*% t(X)  # variance!!   [1x4] x [4X4] x [4X1]
      
      ndf <- if (is.matrix(v))  nrow(v) else 1    # TRUE  #1
      
      se <- as.vector(if (ndf == 1) sqrt(v) else sqrt(diag(v))  )  
      
      Z <- est/se                                  # standard normal
      
      P <- if (length(idf)) 2 * pt(-abs(Z), idf)  else 2 * pnorm(-abs(Z))
      
      lower <- est - zcrit * se
      upper <- est + zcrit * se
  
    resx <- list(Contrast = est, SE = se, Lower = lower, Upper = upper, 
                Z = Z, Pvalue = P,  
                var = v, 
                df.residual = idf, 
                X = X, 
               conf.int = conf.int
                 )
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # end manual contrast
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    
    
  return(list(
    
         res=estx , L=L, H=H, i=i, j=j, f=f, x=x, des.mat=des.mat,
         
         resx=resx,
         
         Xa=xa, Xb=xb, weights=weights, X1=X1, X2=X2, betas=betas, var.cov=var.cov
              
              ))   
        
})


    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



 






 
```

Column {data-width=400}
-------------------------------------
  
### tabx
  
```{r left1, eval=TRUE}  


renderPlot({
  
   df <-  random.sample3()$dd
   
  yy <- ggplot(df, aes(reorder(IV,DV),DV,fill=IV))+

    stat_boxplot(geom ='errorbar',width = 0.4) +
    geom_boxplot(outlier.shape = NA) + #avoid duplication of outliers
    labs(title="Boxplot, dotplot and Standard error of mean for groups", 
         x = "Groups (sorted)",
         y = "Response",
         subtitle ="Blue dots=sample data points, Yellow dot=mean, Red=1 x standard error ",
         caption = "") +
    guides(fill="none") +
    
    geom_jitter(shape=21, fill="blue", color="darkred", size=3, width= 0.1) +
     
    stat_summary(fun.data = mean_se, geom = "errorbar", colour = "red", size = 1, width= 0.1)+
    stat_summary(geom="point", fun=base::mean, color="yellow",  size = 2) +
    theme_bw() 
    print(yy)
  
})


```
Column {data-width=400, height=75}
-----------------------------------------------------------------------
  
### tabz

```{r right2}

renderPlot({
  
   d <-  random.sample3()$dd
   
   df <-  random.sample3()$dd

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  scalez <- c(0.001, 0.01, .1 ,1, 10, 100, 1000, 10000, 1e5 , 1e6)
  top <-    min(which( max(d$DV) < scalez))
  bottom <- max(which( min(d$DV) > scalez))
  scalez <- scalez[bottom:top]
  ticks= log(scalez)
  labs <- exp(ticks)  # exponentiate the labels
  
  df$DV <- log(df$DV)
  
xx<-  ggplot(df, aes(reorder(IV,DV),DV,fill=IV))+
    
    stat_boxplot(geom ='errorbar',width = 0.4) +
    geom_boxplot(outlier.shape = NA) + #avoid duplication of outliers
    labs(title="Boxplot, dotplot and Standard error of mean for groups", 
         x = "Groups (sorted)",
         y = "Response",
         subtitle ="Blue dots=sample data points, Yellow dot=mean, Red=1 x standard error ",
         caption = "") +
    guides(fill="none") +
    
    scale_y_continuous(
      
      limits=c(   ticks[1],  ticks[length(ticks)]  ), 
      breaks= ticks,    # this is where the values go
      labels= labs) +   # these are labels
    
    geom_jitter(shape=21, fill="blue", color="darkred", size=3, width= 0.1) +
    
    stat_summary(fun.data = mean_se, geom = "errorbar", colour = "red", size = 1, width= 0.1)+
    stat_summary(geom="point", fun=base::mean, color="yellow",  size = 2) +
    theme_bw() 
 
print(xx)

})

```  

tab 6
====

Column {.sidebar}
-----------------------------------------------------------------------


Use the inputs below to generate correlated count data !

```{r paired}

  sliderInput('N.p', 'Patients per arm', value=28,
                min = 10, max = 200, step=5, ticks=F)
  
  sliderInput('mu0.p', 'Placebo mean rate \u03BC', value=8,
                min = 0.1, max = 25, step=.05, ticks=F)
  
  sliderInput('eff.p', 'Hypothesised treatment effect ', value=.75,   
                min = 0.5, max = 2, step=.05, ticks=F)
  
  sliderInput('r', 'Correlation', value = c(.20),
                min = -1, max = 1 ,step=0.05, ticks=F)
   
  sliderInput('sims.p', 'Power simulations', value= 10,
                min = 10, max = 1000, step= 100, ticks=F)

```

Row {data-height=275}
-----------------------------------------------------------------------

### xxxxxxxxxxxxxxxx
  

```{r paired txt, eval=TRUE}

reactive({
  
cat(paste0("xxxxxxxxxxx ",input$N.p,"xxxxxxxxxxxxxxx.\n"))

cat(paste0("xxxxxxxxxxxxxxxxxxxx ",input$mu0.p, " xxxxxxxxxxxxxxxx ",input$eff.p,", xxxxxxxxxx " ,input$r,".\n")) 

cat(paste0("\nxxxxxxxxxxxxxxxx"))

cat(paste0("\nxxxxxxxxxxxxxxxxxx"))
cat(paste0("\n1) xxxxxxxxxxxx"))
cat(paste0("\n2) xxxxxxxxxxxx"))
cat(paste0("\n3) xxxxxxxxxxxx"))
 
})

``` 

Row {data-height=250}
-----------------------------------------------------------------------

### tab4


```{r paired results, eval=TRUE}

 
```

   
Row {.tabset .tabset-fade}
-----------------------------------------------------------------------

### tab5
  

```{r paired boxplot, eval=TRUE}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

     

```

### tab6

```{r BAplot}

  

```

Wiki
====
 
xxxxxxxxxxxxxxxxxxxxxxxxx $\alpha$ xxxxxxxxxxxxxxxxxxxxxxxxxx
lines from residials, pi/2 explanation
vickers code
gelmans book residuals
replicates
drop some reps
bioequivalence 4 group pool and ratio?
**xxxxxxxxxxxxxxxxxxxxxxx**

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx  

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 

References
====
```{r, refs}
 
    tags$a(href = "https://pubmed.ncbi.nlm.nih.gov/8337548/", target="_blank",
           tags$span(style="color:blue", "[1] Construction of age-related reference centiles using absolute residuals, Doug Altman shows how to model the SD"),) 
    div(p(" "))
    # tags$a(href = "https://stats.stackexchange.com/questions/27869/fitting-a-poisson-glm-mixed-model-with-a-random-slope-and-intercept",target="_blank",
    #        tags$span(style="color:blue", "[2] Mixed model Poisson"),)
    # div(p(" "))
    
    div(p(" "))
  tags$hr()                        

```