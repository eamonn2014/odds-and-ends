---
title: "METHOD COMPARISON & BEYOND" 
author: 
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: scroll
    social: menu
    source_code: embed
runtime: shiny
---
Paired data
===



```{r global, include=FALSE}

  rm(list=ls())

  set.seed(874765)
  #library(MASS)      # for correlated data generation
  library(flexdashboard)
  library(ggplot2)
  library(gridExtra)
  library(ggpubr)
  library(ggExtra)
  library(shiny)
  library(utf8)      # codes for Greek letters
  library(MethComp)
  library(gridExtra)
  library(tidyverse)
  library(plyr)
  library(rms)
  library(nlme)
  lwd.=3             # used when plotting
  
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # function to format decimals
  # https://stackoverflow.com/questions/3245862/format-numbers-to-significant-figures-nicely-in-r
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  p3 <- function(x) {formatC(x, format="f", digits=3)}
  
  formatz <- function(x){
    
    if (!is.na(x)  ) {
      
      formatC(signif(x,digits=5), digits=5,format="fg", flag="#",big.mark=",")
      
    }
    
  }
  
  formatz0 <- function(x){
    sprintf(x, fmt = '%s')  
  }
  formatz1 <- function(x){
    sprintf(x, fmt = '%#.1f')  
  }
  formatz2 <- function(x){
    sprintf(x, fmt = '%#.2f')  
  }
  formatz00 <- function(x){
    round(x,0) 
  }
  formatz3 <- function(x){
    sprintf(x, fmt = '%#.3f')  
  }
  formatz4 <- function(x){
    sprintf(x, fmt = '%#.4f')  
  }
  
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# function to generate cor data , see count app
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

mvrnorm <- function(n = 1, mu = 0, Sigma) {
  nvars <- nrow(Sigma)
  # nvars x n matrix of Normal(0, 1)
  nmls <- matrix(rnorm(n * nvars), nrow = nvars)
  # scale and correlate Normal(0, 1), "nmls", to Normal(0, Sigma) by matrix mult
  # with lower triangular of cholesky decomp of covariance matrix
  scaled_correlated_nmls <- t(chol(Sigma)) %*% nmls
  # shift to center around mus to get goal: Normal(mu, Sigma)
  samples <- mu + scaled_correlated_nmls
  # transpose so each variable is a column, not
  # a row, to match what MASS::mvrnorm() returns
  t(samples)
}
   
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 # https://stackoverflow.com/questions/6461209/how-to-round-up-to-the-nearest-10-or-100-or-x/6468532#6468532
 # nice function from link to round to selected value

  roundUp <- function(x,to=10)
  {
    to*(x%/%to + as.logical(x%%to))
  }
  
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# try these functions https://github.com/davidski/collector/blob/main/R/fit_distributions.R

# Given a set of parameters describing a lognormal distribution, return
# the parameters of the underlying normal distribution.

lognormal_to_normal <- function(meanlog, sdlog) {
  norm_mean <- exp(meanlog + sdlog^2 / 2)
  norm_sd <- sqrt( (exp(sdlog^2) - 1) * exp(2*meanlog + sdlog^2))
  list(mean = norm_mean, sd = norm_sd)
}

#' normal_to_lognormal(normmean = 20, normsd = 3)
normal_to_lognormal <- function(normmean=10, normsd=2) {
  phi <- sqrt(normsd ^ 2 + normmean ^ 2)
  lognorm_meanlog <- log(normmean ^ 2 / phi)
  lognorm_sdlog <- sqrt(log(phi ^ 2 / normmean ^ 2))
  list(meanlog = lognorm_meanlog, sdlog = lognorm_sdlog)
}

 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# start of app
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

```

Column {.sidebar}
-----------------------------------------------------------------------

**Design your method comparison, a simple setting, no replication **

```{r tab1}

 
 
  sliderInput('n', 'n pairs of data', value=100,
                min = 5, max = 1000, step=5, ticks=F)

  sliderInput('mu0', 'Initial mean  \u03BC', value=0,
                min = -100, max = 100, step=5, ticks=F)
  
  sliderInput('eff.p', 'Constant intervention effect', value = c(0),
                min = -25, max = 25 ,step=1, ticks=F)
  
  sliderInput('sd.', 'Common constant \u03C3', 1,
                min = 1, max = 100, step=1,ticks=F)

  sliderInput('r', 'Correlation \u03C1', value = c(.8),
                min = -.9, max = .9, step=0.05, ticks=F)
  
  selectInput("SD.type", "Select \u03C3 type",          choices = c("cons", "lin"), selected="cons")
  
  selectInput("Dif.type", "Select difference type", choices = c("cons", "lin"), selected="cons")
  
  selectInput("Pl.type", "Select plot",             choices = c("BA", "conv"), selected="BA")
 
  
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   # orange button
   actionButton("resample",   "Hit to simulate a new sample")
      
   #  tags$head(
   tags$style(HTML('#resample{background-color:orange}'))
   # )
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 

```

The top two drop down menus allow different modelling approaches. Note, the default settings reflect the true data generating mechanism.

Column {data-width=400}
-------------------------------------

### Paired boxplots and scatter plot

```{r, tab1 plot3}

   # --------------------------------------------------------------------------
 

renderPlot({
  
  A <- r1()$pp1
  B <- r1()$pp2
  
  m <- ceiling(max(A,B))
  mL <- floor(min(A,B))
  before <- A  
  after <-  B  
  n <- length(before)
  d <- data.frame(y = c(before, after), 
                  x = rep(c(1,2), each=n),
                  id = factor(rep(1:n,2)))
  
  d$xj <- jitter(d$x, amount=.13)
  # code from count app
  AA <- ggplot(data=d, aes(y=y) ) +
    geom_boxplot(aes(x=x, group=x), width=0.2, outlier.shape = NA, col='blue', fill='lightblue') +
    geom_line(aes(x=xj, group=id),  colour='pink', alpha=.5) +
    geom_point(aes(x=xj), size=2) +
    xlab("Phase") + ylab("Count") +  
    scale_x_continuous(breaks=c(1,2), labels=c("Before", "After"), limits=c(0.5, 2.5)) +
   # scale_y_continuous(breaks=c(mL:m), limits=c(mL,m)) +
    theme_bw() + theme(legend.position = "none") 
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ scatter plot
  

  d <- data.frame(y = B , x = A)
  
  BB <- ggplot(d, aes(x, y)) +
    geom_jitter(width = 0.1, height = 0.1, size=2) +
   # scale_x_continuous(breaks=c(0:m), limits=c(mL,m)) +
   # scale_y_continuous(breaks=c(0:m), limits=c(mL,m)) +
    scale_x_continuous( limits=c(mL,m)) +
    scale_y_continuous(  limits=c(mL,m)) +
    xlab("Before count") +ylab("After count") +
    theme_bw() + theme(legend.position = "none") +
    geom_abline(intercept=0, slope=1)
  
  plot1 <- AA
  plot2 <- BB
  grid.arrange(plot1, plot2, ncol=2)


})
  # --------------------------------------------------------------------------


```

### Bland Altman plot (or conversion plot) with 95% limits of agreement, within which we expect 95% of the differences to lie.

```{r, tab1 plot4}

    
  # --------------------------------------------------------------------------


renderPlot({
  
    A <- r1()$pp1
    B <- r1()$pp2
    n <- input$n
    
    d <- data.frame(y = A , x = B)
  
    my_data <- data.frame( 
      group = rep(c("before", "after"), each = n),
      counts = c(d[,1],  d[,2]),
      ID=rep(1:n,2)
    )
  
   m <- Meth(my_data,meth="group",item="ID",repl=NULL,y="counts",print=TRUE)
   
   L <- max(abs(floor(min(A-B))),abs(ceiling(max(A-B))))
   
   L <- roundUp(L)
    
    # we set up const dif and const sd so that will matches true data genrting mechanism
    par( mfrow=c(1,1), mar=c(3,3,1,3), mgp=c(3,1,0)/1.6 )
   
    BA.plot( m, model=NULL, repl.conn=TRUE, col.lines="blue",
             # axlim=c(0,20), 
             diflim=c(-L,L), 
             xaxs="i", yaxs="i",
             las=1, eqn=TRUE,  
             pl.type=input$Pl.type, 
             sd.type=input$SD.type, 
             dif.type = input$Dif.type, # cons is simulatied
             grid=1:9*10, digits=3,font.eqn=1  , eqax=T)

})

  # --------------------------------------------------------------------------
 

```

Column {data-width=400, height=75}
-----------------------------------------------------------------------

### Introduction

```{r tab1 plot1}
 
   # --------------------------------------------------------------------------
    # I looked back to two period cross over trial to get this button working to resimulate
    # This is where a new sample is instigated only random noise is required to be generated
    random.sample <- reactive({
      
    # Dummy line to trigger off button-press
    foo <- input$resample
         
    L1 <-     input$mu0
    L2 <-     input$mu0+input$eff.p
    r  <-     input$r
    n <-      input$n
    sd. <-    input$sd.
    
    
   #  
   # n     =    100
   # mu0   =    0 
   # eff.p =    0 
   # sd.   =    1 
   # r     =  0.8
   #              
   #  
   #  
   #  
   #  
  #     L1 <-     mu0
  #   L2 <-      mu0+ eff.p
  #   
  #   
  # Sigma = sd.  
  #   
  #   require(MASS)
    
    
    
# generate correlated poisson ref: https://thomasward.com/simulating-correlated-data/
# Sample correlated N(0, 1) distributions from a multivariate normal distribution.
# Transform them to correlated Uniform(0, 1) distributions with the normal CDF.
# Transform them to any correlated probability distribution you desire with that probability distributionâ€™s inverse CDF.

    Sigma <- matrix(c(1, r, r, 1), 2, 2)

    px <- mvrnorm(n, Sigma = Sigma)   # correlated continuous, see function in global area!

    U <- pnorm(px, mean = 0, sd = 1)  # correlated uniform
    
    pp1 <- qnorm(U[, 1], L1, sd.)      # correlated normal  
    pp2 <- qnorm(U[, 2], L2, sd.) 
        
    return(list(pp1=pp1, pp2=pp2, sd.=sd.))
    
    })
   
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


  r1 <- reactive({
 
    sample <- random.sample()
     
     r  <-     input$r
     n <-      input$n
     sd. <-    sample$sd.  
 
     pp1 <- sample$pp1     # correlated normal  
     pp2 <- sample$pp2 
    
    cor. <- cor(pp1, pp2)              # capture correlation
 
    # create a data frame
    my_data <- data.frame( 
      group = rep(c("A.before", "B.after"), each = n),
      counts = c(pp1,  pp2),
      ID=rep(1:n,2)
    )

    ## variance of a difference from a simulation
    est <- var(pp1) + var(pp2) - 2 *cor. * sd(pp1) * sd(pp2)
    
    ## true variance of difference
    true <- sd.^2 + sd.^2 - 2 * r * sd. * sd.
    
    ## variance of a sum
    # var(pp1) + var(pp2) + 2 *cor. * sd(pp1) * sd(pp2)
    # 
    # 
    # sd.^2 +sd.^2 + 2 * r * sd.*sd.

 return(list( est=est, true=true , pp1=pp1, pp2=pp2 ))
     
  })
  
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  h5(htmlOutput("text3"))      ## print 
  
```


```{r, test}
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   # https://stackoverflow.com/questions/63507171/shiny-increase-mathjaxs-font-size
   # help on font size
   h5(htmlOutput("text2"))      
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                              withMathJax(
                                tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
                             helpText('
                             $${  
                             {\\sigma^2}{_{x \\pm y}} =  
                             {\\sigma^2}{_{x}}  +   {\\sigma^2}{_{y}} 
                             \\pm 2\\rho{\\sigma}{_{x}} {\\sigma}{_{y}}           
                             }\\!$$'
                             ))   
                             )
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   h5(htmlOutput("text2a"))   
     
                            withMathJax(
                               tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
                             helpText('
                              $${ 
                              \\rho {\\sigma}{_{x}}  {\\sigma}{_{y}}           
                              }\\!$$'))        
  
                            )
    # --------------------------------------------------------------------------
    h5(htmlOutput("text4"))   
    # --------------------------------------------------------------------------
    h5(htmlOutput("text4a"))   
    # --------------------------------------------------------------------------
```

 
```{r } 

  # --------------------------------------------------------------------------
output$text2 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "If the variables are uncorrelated the variance of the difference is equal to the sum of the variances. If there is any correlation this information is incorporated: ")))
  
})
  # --------------------------------------------------------------------------

output$text2a <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "The following is the covariance between the two variables. Add 2 x this if we are interested in the variance of the sum, for the variance of the difference subtract 2 x this component. ")))
  
})
   # --------------------------------------------------------------------------
   

output$text3 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "This is not a typical method comparison experiment. 
               
               Correlated normal data are generated based on the inputs. We have ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", input$n) ,
   
     tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               " samples on two methods. There is a true difference (after - before) of ") 
      
      , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", input$eff.p) ,
     
     
        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
     
    ", also there is a true correlation between the paired results of ")
    
      , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", input$r) ,
    
    
        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
    
    " and between sample SD commmon to both methods of ")
    
      , tags$span(style="color:blue ;font-weight:bold;font-size: 20px;", input$sd.) ,
    
     tags$span(style="color:black;font-weight:bold;font-size: 20px;",
               
    ". By design the SD is constant across the range of values. Think of this SD component as the between person SD. Increase it to see the range of scores increase. We are not particularly interested in the between sample SD, this depends on the samples we choose and it is advisable to select samples that span range of the devices if possible. There are no technical replicates ", #),
    
    
        ".") ))
  # --------------------------------------------------------------------------
 })
 

output$text4 <- renderText({  # create interactive text t1

    print(paste0(   

        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "Based on the true parameters, the variance of the difference, calculated using the above equation, is ") 
    
         , tags$span(style="color:blue ;font-weight:bold;font-size: 20px;",formatz1( r1()$true )),
                     
                     tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
    
     ", this equates to an SD of the differences of ") 
    
       , tags$span(style="color:blue ;font-weight:bold;font-size: 20px;", formatz3(sqrt(r1()$true))) ,
    
     tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               ". The estimate from a simulated experiment is ") 
    
     , tags$span(style="color:blue ;font-weight:bold;font-size: 20px;", formatz3( r1()$est )),
                 
                  tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
    
        ", this equates to an SD of the differences of ")
    
     , tags$span(style="color:blue ;font-weight:bold;font-size: 20px;", formatz3( sqrt(r1()$est)),
    
                 ##add some more text
                  tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
    
        ", this matches the methComp estimate with the default settings, see the estimate in brackets in the Bland Altman plot top right"),".") ))

 })


output$text4a <- renderText({  # create interactive text t1

    print(paste0(   

        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
          
     "Notice there are no technical replicates per sample on each method. The repeatability of each method therefore cannot be estimated, this is a deficiency in the experimental design. Explore the other tabs to see a better design approach using technical replication!")) )

 })




  # --------------------------------------------------------------------------

# see line 1412
 output$text5 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "After anti-logging, the contrast of ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", inference()$i )
    
     , tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               " vrs. ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", inference()$j )
    
       , tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               " estimate is ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", formatz3(inference()$res)) ,
   
     tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               " 95%CI ( ") 
      
      , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", formatz3(inference()$L)) ,
     
     
        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
     
    ",  ")
    
      , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", formatz3(inference()$H) ),
    
    
       tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
    
    " ) ") 
    
  ))
  
})

 

``` 


<!-- tab2 $\alpha$ -->
<!-- ==== -->

<!-- ```{r, not used} -->


<!-- ``` -->
 
Method Comp. Diagnostics
====

<!-- Column {.sidebar} -->
<!-- ----------------------------------------------------------------------- -->


```{r gammapoisson}

                                
    # sliderInput('N.pg', 'Patients per arm', value=1000,
    #               min = 1000, max = 100000, step=5, ticks=F)
    # 
    # sliderInput('mu0.pg', 'Placebo event rate \u03BC per patient yr of follow up', value=1,
    #               min = 0.1, max = 25, step=.05, ticks=F)
    # 
    # sliderInput('eff.pg', 'Hypothesised treatment effect ', value=.75,  # 1/2 ing to doubling
    #               min = 0.5, max = 2, step=.05, ticks=F)
    # 
    # sliderInput('k.pg', 'This needs to be \u03B1 the heterogeneity (ancillary) parameter. \u03B1 = 1/k', value = 1.3 ,  
    #               min = 0, max = 5 ,step=0.01, ticks=F)
    # 
    # sliderInput('d1.pg', 'Placebo discontinuation prob', value = c(0.1),
    #               min = 0, max = .5 ,step=0.05, ticks=F)
    # 
    # sliderInput('d2.pg', 'Treatment discontinuation prob', value = c(0.1),
    #               min = 0, max = .5 ,step=0.05, ticks=F)
    # 
    # sliderInput('fup.pg', 'Follow up (yrs)', value = c(1),
    #         min = 1, max = 10, step=1,ticks=F)

```

Method Comparison Diagnostics
 

Column {data-width=400, height=300}
-----------------------------------------------------------------------

### Constant SD assumption

```{r, gp barplots, eval=TRUE}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 
  r2 <- reactive({
 
    L1 <-     input$mu0
    L2 <-     input$mu0+input$eff.p
    r  <-     input$r
    n <-      input$n
    sd. <-    input$sd.
    

    A <- r1()$pp1
    B <- r1()$pp2
    n <- input$n
    
    d <- data.frame(y = A , x = B)
    
    my_data <- data.frame( 
      group = rep(c("before", "after"), each = n),
      counts = c(d[,1],  d[,2]),
      ID=rep(1:n,2)
    )
    
    m <- Meth(my_data,meth="group",item="ID",repl=NULL,y="counts",print=TRUE)
     
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # code from my useful code, adjusted slightly

  BA <- DA.reg(m, DA.slope = TRUE)

  a1<-as.data.frame(unlist(BA))
  #DA.slope.p<-a1[14,]
  #cons.sd.p.value<-a1[38,]
  
  res<-rbind(a1[14,], a1[38,])
  res<-as.matrix(res)
  
  rownames(res)<-c( 
                   "DA Slope P-value",
                   "P-value for Changing SD")
  
  colnames(res) <- c("Bland Altman Analysis")
 # print(res)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ## **Assess Bland Altman assumptions P-values for two hypotheses:**
  w <- to.wide(m)
  ## assumptions do it yourself

  w$y <- w$before - w$after
  w$y <- w$after - w$before
  
  w$x <-  (w$before + w$after) /2
  
  # Constant difference - this is the test of 0 slope in the regression of differences on averages.
  f <- summary(lm(y~x, w))
  con.diff <- f$coefficients["x","Pr(>|t|)"]
  
   
  
  # Constant variance - this is the test of 0 slope in the regression of absolute residuals on averages.
  w$r <- abs(residuals(f) ) # if you dont use abs the regression line slope will be 0!
  # w$r <- (residuals(f) )
  # plot(r~x,w)
  f1 <- summary(lm(r~x, w))
  con.sd <- f1$coefficients["x","Pr(>|t|)"]
  

  
  return(list( con.diff=con.diff, con.sd=con.sd , w=w ))
  

})

renderPlot({
  
w <- r2()$w
con.sd <- r2()$con.sd
  
  ggplot(w, aes(x=x, y=r))+
    geom_point() +  
    geom_smooth(method="lm", col="black")  +
    stat_regline_equation(label.x = min(w$x), label.y = max(w$r))+
    theme_bw() +
    labs(title = paste0("First regressing the differences on the averages and then regressing the absolute residuals from this on the averages.\nTesting hypothesis slope=0, p=", formatz3(con.sd)),
         x = "Averages",
         y = "Absolute residuals")
   
})

 

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``` 

### Constant difference assumption

```{r nb barplots, eval=TRUE}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

renderPlot({
  
w <- r2()$w
con.diff <- r2()$con.diff

 pitman <- cor.test(w$x, w$y)$p.value
 


  ggplot(w, aes(x=x, y=y))+
    geom_point() +  
    geom_smooth(method="lm", col="black")  +
    stat_regline_equation(label.x = min(w$x), label.y = max(w$r))+
    theme_bw() +
    labs(title = paste0("Regression of differences on averages. Testing hypothesis slope=0, p=", formatz3(con.diff), ". Note: the constant SD assumption can also be evaluated using the \np-value from the correlation of differences on the average (known as Pitman's test) p=", formatz3(pitman)),
         x = "Averages",
         y = "After - before")

})
 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


```
   
Column {.tabset .tabset-fade}
-----------------------------------------------------------------------

### Constant difference assumption
  

```{r diagnostics1, eval=TRUE}

renderPlot({
  
  w <- r2()$w
  con.diff <- r2()$con.diff
  
  mod1 <- lm(y ~ x, data = w) 
  w$pred = predict(mod1)  
  
  p <- w %>%
    ggplot(aes(x = x, y = y) ) +
    geom_point(pch = 21, color = "white", fill = "black", size = 2, alpha = 0.8) +
    geom_smooth(method = "lm", colour = "black", se=TRUE, level=.95, fill="cornflowerblue") +
    stat_regline_equation(label.x = min(w$x), label.y = max(w$y))+
    
     labs(title = 
    paste0("Regression of differences on averages. Testing hypothesis slope=0, p=", formatz3(con.diff)),
         x = "Averages",
         y = "After - before") +

    geom_segment(
      aes(xend = x, yend = pred),
      size = 0.5, alpha = 0.8, lineend = "round", col="pink"
    ) +
    
    theme_bw(base_size = 12)
  
    ggMarginal(p, type = "histogram", bins = 50)

})

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

```

###  Constant variance assumption
 
```{r diagnostics2}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# x averages
# y differences
# r abs residuals

renderPlot({
  
w <- r2()$w

  con.sd <- r2()$con.sd
  
  f <- summary(lm(y~x, w)) # First regressing the differences on the averages 
  w$r <- abs(residuals(f) ) 
  mod1 <- lm(r ~ x , data = w) # regressing the absolute residuals from this on the averages
  
 # pitman <- cor.test(w$r, w$x, data=w)$p.value
  
  
  w$pred = predict(mod1) # pred and fitted no dif with linear model
 # w$pred = fitted(mod1) 

p1 <-  ggplot(w, aes(x=x, y=r))+
    geom_point(pch = 21, color = "white", fill = "black", size = 2, alpha = 0.8) +
    geom_smooth(method = "lm", colour = "red", se=TRUE, level=.95, fill="#69b3a2") +
     stat_regline_equation(label.x = min(w$x), label.y = max(w$r))+
    theme_bw() +
    labs(title = paste0("First regressing the differences on the averages and then regressing the absolute residuals from this on the averages. Testing hypothesis slope=0, p=", formatz3(con.sd)),
         x = "Averages",
         y = "Absolute residuals") +
    
    geom_segment(
      aes(xend = x, yend = pred),   ## trying to join to reg line
      size = 0.5, alpha = 0.8, lineend = "round", col="pink"
    ) +
    
    theme_bw(base_size = 12)

  ggMarginal(p1, type = "histogram", bins = 50)

})
  

```

### histogram of differences
  

```{r diagnostics3, eval=TRUE}
 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# https://statisticsglobe.com/normal-density-curve-on-top-of-histogram-ggplot2-r
# calculate mean and sd by group
# stats <- aggregate(y~1, w, function(x) c(mean=mean(x), sd=sd(x)))
 

renderPlot({
  
w <- r2()$w

  df <- w
  
  argz1 <- c(   mean(df$y),   input$eff.p)
  argz2 <- c(   sd(df$y),     sqrt(r1()$true) )
  colz <-  c("black", "red")
  
  xv <- argz1[2]+1.2

 p <- ggplot(df, aes(y)) +      
  
  geom_histogram(aes(y = ..density..),
                 colour = "white", fill = "cornflowerblue", size = 0.1) +
 
   theme_bw() +
  
  annotate("text",  x=xv, y=.8, label= paste0("Estimated Mean differences = ", formatz3(mean(df$y))," and SD of differences = ",          formatz3(sd(df$y)), " (black)"))  +
  annotate("text",  x=xv, y=.7, label= paste0("True Mean difference = ",      formatz3( input$eff.p),", and true SD of differences = " ,  formatz3(sqrt(r1()$true)) ,  " (red)"))
  
# https://stackoverflow.com/questions/2237600/how-can-i-plot-multiple-functions-in-r
 # adding density plots
 for(i in 1:2)
   
    p <- p +  stat_function(fun = dnorm,
                args = list( mean = argz1[i], sd = argz2[i] ),
                col = colz[i],
                size = 1.5)
    print(p)

})

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 
```

### not used yet 
 
 
```{r diagnostics4}

  
```

### not used yet
 
 
```{r diagnostics5}

   

```

### not used yet

```{r diagnostics6, eval=TRUE}

```

 
Method Comp. (no replication)
===


Column {.sidebar data-width=350}
-----------------------------------------------------------------------

**Design your method comparison, a simple setting, no replication, sample are chosen uniformally to span the range**

```{r tab1q}
 
  
       sliderInput('nq', 'n pairs of data', value=100,
                min = 5, max = 1000, step=5, ticks=F)
 
       sliderInput("res", 
               "Select method variation (m1 , m2)", 
               min = 0, max = 20, value = c(5, 4), ticks=FALSE) 
  
       # sliderInput("btw", 
       #         "Select between?", 
       #         min = 0, max = 20, value = c(1, 1), ticks=FALSE) 
  
       sliderInput("alphas",  step=0.1,
               "Select alphas (m1, m2)", 
               min = -5, max = 5, value = c(0, 0), ticks=FALSE) 
   
       sliderInput("betas", 
               "Select betas (m1, m2)", step=.01,
               min = -1, max = 1, value = c(0.9, .92), ticks=FALSE) 
      
       sliderInput("ranges", 
               "Select range over which methods measure", 
               min = 0, max = 100, value = c(0, 10), ticks=FALSE) 
      
        
  
  
  
  selectInput("SD.typeq", "Select \u03C3 type",          choices = c("cons", "lin"), selected="cons")
  
  selectInput("Dif.typeq", "Select difference type", choices = c("cons", "lin"), selected="lin")
  
  selectInput("Pl.typeq", "Select plot",             choices = c("BA", "conv"), selected="BA")
 
  
  
  
  
  
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   # orange button
   actionButton("resampleq",   "Hit to simulate a new sample" , style = "width:100%;")
      
   #  tags$head(
   tags$style(HTML('#resampleq{background-color:orange}'))
   # )
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 

```

The top two drop down menus allow different modelling approaches. Note, the default settings reflect the true data generating mechanism.

Column {data-width=400}
-------------------------------------

### Paired boxplots and scatter plot

```{r, tab2q}

 

renderPlot({
  
  A <- r1q()$pp1  # method 1
  B <- r1q()$pp2
  
  m <- ceiling(max(A,B))
  mL <- floor(min(A,B))
  before <- A  
  after <-  B  
  n <- length(before)
  d <- data.frame(y = c(before, after), 
                  x = rep(c(1,2), each=n),
                  id = factor(rep(1:n,2)))
  
  d$xj <- jitter(d$x, amount=.13)
  # code from count app
  AA <- ggplot(data=d, aes(y=y) ) +
    geom_boxplot(aes(x=x, group=x), width=0.2, outlier.shape = NA, col='blue', fill='lightblue') +
    geom_line(aes(x=xj, group=id),  colour='pink', alpha=.5) +
    geom_point(aes(x=xj), size=2) +
    xlab("Method") + ylab("y") +  
    scale_x_continuous(breaks=c(1,2), labels=c("1", "2"), limits=c(0.5, 2.5)) +
   # scale_y_continuous(breaks=c(mL:m), limits=c(mL,m)) +
    theme_bw() + theme(legend.position = "none") 
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ scatter plot
  

  d <- data.frame(y = B , x = A)
  
  BB <- ggplot(d, aes(x, y)) +
    geom_jitter(width = 0.1, height = 0.1, size=2) +
   # scale_x_continuous(breaks=c(0:m), limits=c(mL,m)) +
   # scale_y_continuous(breaks=c(0:m), limits=c(mL,m)) +
    scale_x_continuous( limits=c(mL,m)) +
    scale_y_continuous(  limits=c(mL,m)) +
    xlab("1") +ylab("2") +
    theme_bw() + theme(legend.position = "none") +
    geom_abline(intercept=0, slope=1)
  
  plot1 <- AA
  plot2 <- BB
  grid.arrange(plot1, plot2, ncol=2)


})
  # --------------------------------------------------------------------------


```

### Bland Altman plot (or conversion plot) with 95% limits of agreement, within which we expect 95% of the differences to lie.

```{r, tab3q}

    
  # --------------------------------------------------------------------------


renderPlot({
  
    A <- r1q()$pp1
    B <- r1q()$pp2
    n <- input$nq
    
    d <- data.frame(y = A , x = B)
  
    my_data <- data.frame( 
      group = rep(c("1", "2"), each = n),
      counts = c(d[,1],  d[,2]),
      ID=rep(1:n,2)
    )
  
   m <- Meth(my_data,meth="group",item="ID",repl=NULL,y="counts",print=TRUE)
   
   L <- max(abs(floor(min(A-B))),abs(ceiling(max(A-B))))
   
   L <- roundUp(L)
    
    # we set up const dif and const sd so that will matches true data genrting mechanism
    par( mfrow=c(1,1), mar=c(3,3,1,3), mgp=c(3,1,0)/1.6 )
   
    BA.plot( m, model=NULL, repl.conn=TRUE, col.lines="blue",
             # axlim=c(0,20), 
             diflim=c(-L,L), 
             xaxs="i", yaxs="i",
             las=1, eqn=TRUE,  
             pl.type=input$Pl.typeq, 
             sd.type=input$SD.typeq, 
             dif.type = input$Dif.typeq, # cons is simulatied
            #grid=TRUE,#-L:L,#1:9*10,
            N.grid=100,
            grid=-input$ranges[2]:input$ranges[2],
             digits=3,
            font.eqn=3  , 
            eqax=T)
    
    
if ( input$Pl.typeq=="conv") abline(a=0, b=1,   lty=2, col = "purple", lwd=2)

    

})

  # --------------------------------------------------------------------------
 

```

Column {.tabset .tabset-fade}
-----------------------------------------------------------------------

### Introduction

```{r tab4q plot1}
 
   # --------------------------------------------------------------------------
    # I looked back to two period cross over trial to get this button working to resimulate
    # This is where a new sample is instigated only random noise is required to be generated
random.sampleq <- reactive({
      
    # Dummy line to trigger off button-press
        foo <- input$resampleq
         
        n <- input$nq[1]  # size
        
        s1 <- input$res[1]
        s2 <- input$res[2]     # 
        
        if (s1 %in% 0) s1=0.001 
        if (s2 %in% 0) s2=0.001 
        
        # btw1 <- input$btw[1]  # sd
        # btw2 <- input$btw[2]
        # 
        # if (btw1 %in% 0) btw1=0.001 
        # if (btw2 %in% 0) btw2=0.001 
        
        a1 <- input$alphas[1]  # sd
        a2 <- input$alphas[2]
    
        b1 <- input$betas[1]  # sd
        b2 <- input$betas[2]
    
        r1 <- input$ranges[1]  # sd
        r2 <- input$ranges[2]
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        # use the methcomp approach
    
      Nm = 2 # methods , fix this
      Nr = 1 # reps pre sample , fix this
      nr = Nr
      Ni = n
      alpha = c(a1,a2) #rep(a, Nm)
      beta =  c(b1,b2) #rep(b, Nm)
      mu.range =c(r1,r2)    #  this will influence mean, the middle of this and correlation
      
    #  sigma.mi = c(btw1, btw2) #rep(btw,Nm)
      sigma.ir = 0
      sigma.mir = c(s1,s2) #  rep(res, Nm)
       
      
      meth <- rep(1:Nm, Ni)
      item <- rep(1:Ni, each = Nm)
      reps <- rep(Nr, length(meth))
        
      dfr <- data.frame(meth = meth, item = item)[rep(1:length(meth), reps), ]
      dfr <- MethComp::make.repl(dfr)
      
      meth <- dfr$meth
      item <- dfr$item
      repl <- dfr$repl
    
      mu <- runif(Ni, mu.range[1], mu.range[2])
      mu <- mu[item]
    
      # this will be 0
      e.ir <- rnorm(nlevels(IR <- interaction(item, repl)), mean = 0, sd = sigma.ir)
      e.ir <- e.ir[as.integer(IR)]
      
    #  e.mi <- rnorm(nlevels(MI <- interaction(meth, item)), mean = 0, sd = sigma.mi) 
         e.mi <- rnorm(nlevels(MI <- interaction(meth, item)), mean = 0, sd = 0) 
      e.mi <- e.mi[as.integer(MI)]
      
      e.mir <- rnorm(nrow(dfr), mean = 0, sd = sigma.mir[meth])
      
      betavec <- beta[meth]
      
      alphavec <- alpha[meth]
      
      y <- alphavec + betavec * (mu + e.mi + e.ir) + e.mir
      
      dfr <- data.frame(dfr, y = y)
      
      r1 <- dfr
   
     pp1 <- r1[r1$meth %in% 1,"y"]
     pp2 <- r1[r1$meth %in% 2,"y"]
    
   #  true <- sum(sigma.mi^2) + sum(sigma.mir^2)
     
     true <-  sum(sigma.mir^2)
      return(list(pp1=pp1, pp2=pp2, r1=r1, true=true))
     })
   
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


  r1q <- reactive({
 
    sample <- random.sampleq()
     
     true <- sample$true
    
     n <-      input$nq
     sd. <-    sample$sd.  
 
     pp1 <- sample$pp1     
     pp2 <- sample$pp2 
    
    cor. <- cor(pp1, pp2)              # capture correlation
 
    # create a data frame
    my_data <- data.frame( 
      group = rep(c("A.before", "B.after"), each = n),
      counts = c(pp1,  pp2),
      ID=rep(1:n,2)
    )

    ## variance of a difference from a simulation
    est <- var(pp1) + var(pp2) - 2 *cor. * sd(pp1) * sd(pp2)
    
  return(list( est=est, true=true , pp1=pp1, pp2=pp2, cor.=cor.))
     
  })
  
 
    # s1 <- input$res[1]
    #     s2 <- input$res[2]     # mean
    #     
    #     btw1 <- input$btw[1]  # sd
    #     btw2 <- input$btw[2]
    # 
    #     a1 <- input$alphas[1]  # sd
    #     a2 <- input$alphas[2]
    # 
    #     b1 <- input$betas[1]  # sd
    #     b2 <- input$betas[2]
    # 
    #     r1 <- input$ranges[1]  # sd
    #     r2 <- input$ranges[2]
  
    h5(htmlOutput("textmc2.1"))  
    h5(htmlOutput("textmc2.2"))  
    h5(htmlOutput("textmc2.3"))  
    h5(htmlOutput("textmc2.4"))  
   
  output$textmc2.1 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "A method comparison with ") 
    
            , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", 
                        
                        input$nq) ,
    
     tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               " samples assayed on each of two methods. Samples are selected to span the measurement range uniformly. There is a true difference (method 1 - method 2) of ") 
      
       , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", 
                  
                  diff(input$alphas)) ,
    
     tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
    
     " there is a true difference in slopes of  ") 
      
      , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", 
                  
                  diff(input$betas)) ,
    
     tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
    
     " with method 1's slope of  ") 
      
      , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", 
                  
                  input$betas[1]) ,
    
     tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
    
     " and method 2's slope of  ") 
      
      , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", 
                  
                  input$betas[2]) ,
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;",
    
     ", true method 1 standard deviation ")

       ,tags$span(style="color:blue;font-weight:bold;font-size: 20px;",

                   input$res[1]) ,

       tags$span(style="color:black;font-weight:bold;font-size: 20px;",

     ", true method 2 standard deviation ")

       , tags$span(style="color:blue;font-weight:bold;font-size: 20px;",

                   input$res[2]) ,

  #   tags$span(style="color:black;font-weight:bold;font-size: 20px;",

   #  ", also there is a true between sample variability for method 1 of ")

 #       , tags$span(style="color:blue;font-weight:bold;font-size: 20px;",
 # 
 #                   input$btw[1]) ,
 # 
 #     tags$span(style="color:black;font-weight:bold;font-size: 20px;",
 # 
 # ", also there is a true between sample variability for method 2 of ")
 # 
 #       , tags$span(style="color:blue;font-weight:bold;font-size: 20px;",
 # 
 #                   input$btw[2]) ,

    
        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 

    ". There are no technical replicates.") 
 
 
 
 ))
  # --------------------------------------------------------------------------
 })
  
  
   output$textmc2.2 <- renderText({  # create interactive text t1  

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;",   
               
               "The true prediction variance between the methods is  ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", 
                 
                 formatz3(r1q()$true) ),
   
        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 

    ". The estimate from the simulated experiment is ") 
 
  , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", 
                 
                 formatz3(r1q()$est) )
 
,  tags$span(style="color:black;font-weight:bold;font-size: 20px;", 

    ". Respective SDs of ") 
  
  , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", 
                 
                 formatz3(sqrt(r1q()$true)) )
  
   , tags$span(style="color:black;font-weight:bold;font-size: 20px;", 

    " and ") 
  
  , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", 
                 
                formatz3(sqrt( r1q()$est) ))
  
   , tags$span(style="color:black;font-weight:bold;font-size: 20px;", 

    " (check this to the plot when constant SD and constant differences are assumed). ") 
  
 
    
    
         ))
   # --------------------------------------------------------------------------
 })
  
  
  
    
   output$textmc2.3 <- renderText({  # create interactive text t1  

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;",   
               
               "Note the correlation estimated as  ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", 
                 
                 formatz3(r1q()$cor.) ),
   
        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 

    ". This is not useful when measuring agreement. Change the range of the data and observe the change in correlation!") 
 
  
  
 
    
    
         ))
   })
   # --------------------------------------------------------------------------
 
  
 output$textmc2.4 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "Without technical replication the repeatability and method x sample variance components are lumped together. ")))
  
})
     # --------------------------------------------------------------------------

  
   
  
  
  
  
```

### Constant difference assumption
  

```{r xx1, eval=TRUE}


```

###  Constant variance assumption
 
```{r xx2}


```

Method Comp with replicates!      
===

Column {.sidebar data-width=380}
-----------------------------------------------------------------------

**Design your method comparison, replication! **

```{r mc2}
 
#   
# textInput('methodz', 
#           strong(div(h5(tags$span(style="color:blue", 
#             "No of methods, No of sample")))), "2, 20")
#  textInput('samplez', 
#            strong(div(h5(tags$span(style="color:blue", 
#              "No of items")))), "20")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# orange button

  actionButton("resample_2",   "Hit to simulate a new sample", style = "width:100%;")

 
       
   tags$style(HTML('#resample_2{background-color:orange}'))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
output$text.reg.notes2 <- renderText({  # create text

    print(paste0(   

        tags$span(style="color:blue;font-size: 15px;", 
          
     "In the methods box the first entry is the no. of methods (try changing the 3 to 2!). The following are those that are presented in the the figures!")) )

 })

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  h5(htmlOutput("text.reg.notes2"))    
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 splitLayout(
       textInput('methodz', 
          strong(div(h5(tags$span(style="color:blue", 
            "No of methods")))), "3,1,2"),
       
 textInput('samplez', 
           strong(div(h5(tags$span(style="color:blue", 
             "No of samples")))), "20"),
 
textInput('repz', 
          strong(div(h5(tags$span(style="color:blue", 
           "Reps")))), "2,1")
                           )

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
output$text.reg.notes <- renderText({  # create text
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    print(paste0(   

        tags$span(style="color:blue;font-size: 15px;", 
          
     "Vectors of method-specific intercepts and slopes for the linear equation relating the 'true' underlying sample mean measurement to the mean measurement on each method")) )

 })

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  h5(htmlOutput("text.reg.notes"))    

 splitLayout(
    textInput('alphaz', 
              strong(div(h5(tags$span(style="color:blue", 
            "alphas")))), "0,0.4,0"),
    
    textInput('betaz', 
              strong(div(h5(tags$span(style="color:blue", 
              "betas")))), "1,1,1")
)
 
 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  textInput('sigma.irz', 
            strong(div(h5(tags$span(style="color:blue", 
              "sigma.ir produces 'IxR' specific shift \u03C3s for the sample by replicate random effect. Only one can be estimated, if >0 this means reps are linked! The minimum reps (above box) only come into play if this is zero!")))), "0.05")
# 0.02,0.03, 0.05
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
  textInput('sigma.miz', 
            strong(div(h5(tags$span(style="color:blue", 
              "sigma.mi produces 'MxI' Method-specific shifts \u03C3s for a method by sample random effect. Some or all components can be zero.")))), "0.062,0.062, 0.05")

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  textInput('sigma.mirz', 
            strong(div(h5(tags$span(style="color:blue", 
              "sigma.mir 'res' A vector of method-specific residual \u03C3s for a method by sample by replicate random effect (residual variation). All components must be greater than zero.")))), "0.128,0.143, 0.222")
 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  textInput('mu.rangez', 
            strong(div(h5(tags$span(style="color:blue", 
              "The range across items of the 'true' mean measurement. Sample means are uniformly spaced across the range. ")))), "-0.5 ,1")
 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  textInput('mizz', 
            strong(div(h5(tags$span(style="color:blue", 
             "Fraction of the observations from each method to keep, fraction of the observations from each sample to keep")))), "1 ,1")
 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  selectInput("Pl.typez", 
              strong(div(h5(tags$span(style="color:blue",
              "Select plot type (main top left)")))),  choices = c("BA", "conv"), selected="BA")
    
  selectInput("modelz", 
                strong(div(h5(tags$span(style="color:blue",
              "Model: replicates exchangable or linked?")))),  
              choices = c("exch", "linked"), selected="exch")
  
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  

```

...have fun...

Column {data-width=400}
-------------------------------------

### Bland Altman or conversion plot, comparison and plot can be selected by user (lines joining dots only applicable for linked replicates). Note: Here we fit a model on subsetted data only so may not match model results on the full data (more than 2 methods). Restrict overall simulated experiment to 2 methods to see!

```{r, mc2 B}

   # --------------------------------------------------------------------------
 

renderPlot({
  
  foo <- r1_2()$foo  # bring in data
   
  xx <- random.sample_2()  # bring in methods to plot
  
# f<- Meth( data=foo  ,meth="meth",
#           item="item", repl="repl", y="y",  
#           keep.vars=!is.null(data) , print=F) 


f <- foo

f <- Meth(f)

par(mar=c(5.1,4.1,4.1,4))

   # explain how the limits are calculated
   sample <- random.sample_2()
   irz <-    sample$irz 
   if(irz >0) {des ="linked"} else {des="exchangeable"}


BA.plot(f, 
        
        main=paste0("By design the reps are " , des, ". The limits below are based on ",input$modelz," reps,\n change this if necessary using input on bottom left.\nTrue \u03C3 for predictions : ", truth()$true.sd.pred,""),
      
        
        wh.comp=c(xx$mz[2], xx$mz[3]), 
      
        model=input$modelz,
      
        repl.conn=TRUE, 
      col.lines="gray60", 
      col.conn = "brown",
        col.eqn = "black" ,
        font.eqn = 3,
       # axlim=c(-1.5,.75), 
      
       # diflim=c(-20,20), 
      xaxs="i", yaxs="i",
      col.points='blue',
        #cex.points = 0.5,
        las=1, eqn=TRUE, eqax=TRUE, 
        # dif.type="cons",
        # sd.type="cons",
      
 #       dif.type=input$Dif.typez,
  #      sd.type=input$SD.typez,
        pl.type=input$Pl.typez, 
      
        #grid=seq(-1.6,.8,.1), 
        grid=TRUE,
        digits=3 ,
        Transform=F, 
        
        col.grid=gray(0.9))

if ( input$Pl.typez=="conv") abline(a=0, b=1,   lty=2, col = "purple", lwd=2)


})
  # --------------------------------------------------------------------------


```

### Plots showing relationships between all methods

```{r, mc2 C}

    
  # --------------------------------------------------------------------------


renderPlot({
  
    foo <- r1_2()$foo
   
    plot(foo)
    
})

  # --------------------------------------------------------------------------
 

```

Column {.tabset .tabset-fade}
-----------------------------------------------------------------------

### Introduction

```{r mc2 D}
 
   # --------------------------------------------------------------------------
    # I looked back to two period cross over trial to get this button working to resimulate
    # This is where a new sample is instigated only random noise is required to be generated

 random.sample_2 <- reactive({
      
    # Dummy line to trigger off button-press
    foo <- input$resample_2
    
   nz <-     as.numeric(unlist(strsplit(input$samplez,   ",")))
   mz <-     as.numeric(unlist(strsplit(input$methodz,   ",")))
   az <-     as.numeric(unlist(strsplit(input$alphaz,    ",")))
   bz <-     as.numeric(unlist(strsplit(input$betaz,     ",")))
   rz <-     as.numeric(unlist(strsplit(input$repz,      ",")))
   miz <-    as.numeric(unlist(strsplit(input$sigma.miz, ",")))
   irz <-    as.numeric(unlist(strsplit(input$sigma.irz, ","))) # item x replicate
   mirz <-   as.numeric(unlist(strsplit(input$sigma.mirz,",")))
   rangez <- as.numeric(unlist(strsplit(input$mu.rangez,",")))
   mizz <-   as.numeric(unlist(strsplit(input$mizz,      ",")))
   irz=irz[1]
   
   
  #test data
  # mz=methodz=c(3,1,2)
  # nz=samplez=20
  # rz=repz =c(2,1)
  # az=alphaz=c(0,0.4,0)
  # bz=betas=c(1,1,1)
  # irz=sigma.irz=c(0.0)
  # miz=sigma.miz=c(0.062,0.062, 0.05)
  # mirz=sigma.mirz=c(0.128,0.143, 0.222)
  # rangez =mu.rangez=c(-0.5 ,1)
  # mizz=c(1 ,1)
  # modelz="exch"
  # #   
   
  foo <- Meth.sim(Ni=nz[1] , 
                   Nm=mz[1],
                
                Nr=rz[1], 
                nr=rz[2],
                alpha=az, 
                beta= bz,
                
                m.thin=mizz[1], 
                i.thin=mizz[2],
                
                sigma.mi=miz, 
                sigma.ir=irz, 
                sigma.mir=mirz , 
                
                mu.range=rangez
                )
  
  
  # break down Meth.sim for more detail on listing
  
   
  
  
   
   #BA.est(foo, linked=TRUE)
  
  
  
  
        
    return(list(foo=foo, miz=miz, irz=irz, mirz=mirz, mz=mz))
     })
   
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
truth <- reactive({

   sample <- random.sample_2() 
   wh.comp=c(sample$mz[2], sample $mz[3])

   miz <-    sample$miz  # method x item
   mirz <-   sample$mirz # residual/repeatability

   true.sd.pred <- sqrt(sum(sample$miz[wh.comp]^2)+sum(sample$mirz[wh.comp]^2))

 return(list( true.sd.pred = true.sd.pred))
     
  })


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  r1_2 <- reactive({
 
   sample <- random.sample_2()
    
   nz <-     as.numeric(unlist(strsplit(input$samplez,   ",")))
   mz <-     as.numeric(unlist(strsplit(input$methodz,   ",")))
   az <-     as.numeric(unlist(strsplit(input$alphaz,    ",")))
   bz <-     as.numeric(unlist(strsplit(input$betaz,     ",")))
   rz <-     as.numeric(unlist(strsplit(input$repz,      ",")))
   
   miz <-    sample$miz  # the sds
   irz <-    sample$irz
   mirz <-   sample$mirz
   
   rangez <- as.numeric(unlist(strsplit(input$mu.rangez, ",")))
   mizz <-   as.numeric(unlist(strsplit(input$mizz,      ",")))
    
    # repeat the data generation the sds will produce fresh data
   foo <-  Meth.sim(Ni=nz[1] , 
                   Nm=mz[1],
                Nr=rz[1], 
                nr=rz[2],
                alpha=az, 
                beta= bz,
                m.thin=mizz[1], 
                i.thin=mizz[2],
                
                sigma.mi=miz, 
                sigma.ir=irz[1], 
                sigma.mir=mirz , 
                
                mu.range=rangez
                )
     

 return(list( foo=foo ))
     
  })
  
  
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  h5(htmlOutput("textmcr1"))   
   h5(htmlOutput("textmcr2")) 
    h5(htmlOutput("textmcr3")) 
    h5(htmlOutput("textmcr4")) 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
  output$textmcr1 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "Analyse a simulated study that includes technical replication. Replicates are needed to assess repeatability. The assumptions (contant variance and constant difference are evaluated using the data but ignoring the technical replication. Boxplots are presented, but in retrospect they are not very informative, but left as lesson on coding. The analysis itself explicitly takes into account the study design and replication. We analyse the data in two ways, considering the replicates are linked and considering they are exchangable. We also perform a hypothesis test to test whether there is evidence the repeatabilty methods are different to each other. We also permute the replicates and plot. The limits should be similar if replicates are exchangeable.\n"),
    
        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "Changing differences across the range of values can be a manifestation of different repeatabilities, try it and see. So replication in the design can help to draw this conclusion"))

    )
  
})
    output$textmcr2 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
      "There will always only be one variance estimated for IR, each item replicate is unique. If there are only two methods we can only estimate one method x item component. More than 2 and we can estimate each.\n"))

    )
  
})
  
    output$textmcr3 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
      "Examine the BA.est output ('Analysis, exchangable reps' and 'Analysis, linked reps' tabs) - this gives the limits of agreement between all pairs of methods.\n"))

    )
  
})
  
  
      output$textmcr4 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:blue;font-weight:bold;font-size: 20px;", 
               
      "The agreement between methods is considered acceptable if the variability between the observations made with different methods on the same subject is not much larger than the variability between observations with the same method on this subject.\n"))

    )
  
})
  
  
  
  
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 # h5(htmlOutput("text3z"))      ## print 
  

        
     
```

### Analysis, exchangable reps
 

```{r mcomp2.2}

# not used yet
 
lmm <-  reactive({
  
    foo <- r1_2()$foo

    f <- BA.est( foo, linked=FALSE, IxR =TRUE, MxI = TRUE )
    
   return(list(f=f, foo=foo))
       
   })


  renderPrint({
  
    m1 <-  lmm()$f
     foo <- r1_2()$foo
    
   cat("\nTo calculate the sd.pred for 2 methods sum each method's component's (MxI^2, res^2) and take the square root. The itemÃ—replicate (IxR)
standard deviation is not needed as the replicates are not linked and should be zeros.\n")
    print(m1)
    cat("\nCheck within a method, residual * sqrt(2) gives the standard deviation of the differences below,  multiply this by 2 to give 95% Limit of Agreement\n")
    print(m1$RepCoef)
    cat("\nLet's run the lme model:\n")
    
     mz <-     as.numeric(unlist(strsplit(input$methodz,   ",")))

        # Bendix book page 144 re pdIdent v pdIdiag
    if (mz[1] < 3) {
      
    a <-  lme( y ~ meth + item,
          random=list( item = pdIdent( ~ meth-1 )  ),
          weights = varIdent( form = ~1 | meth ),
          data = foo )
      
    b <-  lme( y ~ meth + item,
          random=list( item = pdIdent( ~ meth-1 )  ),
          #weights = varIdent( form = ~1 | meth ),
          data = foo )
      
      print(a)
      cat("\nEvidence against null of similar repeatabilities?\n")
      print(anova(a,b)) #evidence of different residual errors?
      
  } else {
    
      a <- lme( y ~ meth + item,
          random=list( item = pdDiag( ~ meth-1 )  ),
          weights = varIdent( form = ~1 | meth ),
          data = foo )
    
      b <- lme( y ~ meth + item,
          random=list( item = pdDiag( ~ meth-1 )  ),
          #weights = varIdent( form = ~1 | meth ),
          data = foo )
      print(a)
      cat("\nEvidence against null of similar repeatabilities?\n")
      print(anova(a,b)) #evidence of different residual errors?
    
    
  }
  })
  
 
```

### Analysis, linked reps
  

```{r mcomp2.3}

 
  lmm1 <-  reactive({
  
    foo <- r1_2()$foo

    fL <- BA.est( foo, linked=TRUE, IxR =TRUE, MxI = TRUE  )

    return(list( fL=fL))
           
     })


  renderPrint({
  
     m2 <- lmm1()$fL
      foo <- r1_2()$foo
     cat("\nTo calculate the sd.pred for 2 methods sum each method's component's (MxI^2, res^2) and take the square root. The itemÃ—replicate (IxR)
standard deviation is not related to the method comparison, but only to the study design it is not an effect of any predictive relevance.\n")
     print(m2)
     cat("\nCheck within a method, residual * sqrt(2) gives the standard deviation of the differences below,  multiply this by 2 to give 95% Limit of Agreement\n")
     print(m2$RepCoef)
     cat("\nLet's run the lme model:\n")
    
     mz <-     as.numeric(unlist(strsplit(input$methodz,   ",")))

        # Bendix book page 144 re pdIdent v pdIdiag
    if (mz[1] < 3) {
      
      
    a <-lme( y ~ meth + item,
          random=list( item = pdIdent( ~ meth-1 ), repl = ~ 1 ),
          weights = varIdent( form = ~1 | meth ),
          data = foo )
    
    b <-lme( y ~ meth + item,
          random=list( item = pdIdent( ~ meth-1 ), repl = ~ 1 ),
          #weights = varIdent( form = ~1 | meth ),
          data = foo )
      
     print(a)
      cat("\nEvidence against null of similar repeatabilities?\n")
      print(anova(a,b)) #evidence of different residual errors?
      
      
  } else {
    
      a <- lme( y ~ meth + item,
          random=list( item = pdDiag( ~ meth-1 )  , repl = ~ 1 ),
          weights = varIdent( form = ~1 | meth ),
          data = foo )
      
      b <- lme( y ~ meth + item,
          random=list( item = pdDiag( ~ meth-1 )  , repl = ~ 1 ),
         # weights = varIdent( form = ~1 | meth ),
          data = foo )
      
       print(a)
      cat("\nEvidence against null of similar repeatabilities?\n")
      print(anova(a,b)) #evidence of different residual errors?
      
      
  }
     
  
   })

 
 
```

### A No constraints
  

```{r not metcomp}
 
    h5(htmlOutput("textzz1"))
    h5(htmlOutput("textref")) 
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  

     output$textzz1 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:blue;font-weight:bold;font-size: 20px;", 
               
      "\nReference LME model, a symmetric matrix structure for both between-subject & within-subject variances. No Equality Constraints.\n"))

    )
  
})
  
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
     
  output$textref<- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:blue;font-weight:bold;font-size: 20px;", 
               
      "\nPrediction SD...")
    
      , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", formatz3(Roy()$sd.pred )  ) 
    
    ,  tags$span(style="color:blue;font-weight:bold;font-size: 20px;", 
               
      " <- only coded to work for 2 methods presently, so change no. of methods to 2 to compare to Methcomp!")

    ))
  
})
  
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  

   renderPrint({
  
        f <- Roy()$REF
        print(f)

   })
  
    
 
```

### B flex within only
  

```{r not metcomp2}
   
  
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  

     h5(htmlOutput("textzz2")) 
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
     output$textzz2<- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:blue;font-weight:bold;font-size: 20px;", 
               
      "\nSpecify a compound symmetric matrix structure
for between-subject (i.e. Equality constraint imposed) & symmetric structure within-subject variances.\n"))
)
    
     })       
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  

       renderPrint({
    
        f <- Roy()$NMB
        print(f)
        
      })
     
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  

```

### C flex Btwn only
  

```{r not metcomp3, eval=TRUE}
   
  
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  

     h5(htmlOutput("textzz3")) 
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
     output$textzz3<- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:blue;font-weight:bold;font-size: 20px;", 
               
      "\nSpecify a symmetric matrix structure for
between-subject & compound symmetric structure
within-subject variances (i.e. Equality Constraint imposed)\n"))
)
    
     })       
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
     
  renderPrint({ 
    
      f <- Roy()$NMW
      print(f)
      
   })
   
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
  

```

### D flex within btwn
  

```{r not metcomp4, eval=TRUE}
   
  
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  

     h5(htmlOutput("textzz4")) 
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
     output$textzz4<- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:blue;font-weight:bold;font-size: 20px;", 
               
      "\nSpecify a compound symmetric matrix structure
for both between-subject & within-subject variances.\n"))
)
    
     })       
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  

     
   renderPrint({
        
        f <- Roy()$NMO
        print(summary(f))
        
     })
     
 
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  

    #file:///C:/Users/Lenovo/OneDrive/Documents/PAPERS/METHOD%20COMPARISON/new%20meth%20comp%20for%20K%20obrien.pdf

  Roy<- reactive({
 
   foo <- r1_2()$foo  # data
   
     REF = lme(y ~ meth,
      data = foo,
     random = list(item=pdSymm(~ meth-1)),
    #random = list(item=pdSymm(~ meth-1), repl = ~ 1 ),
      weights=varIdent(form=~1|meth),
      correlation = corSymm(form=~1 | item/repl),
      method="ML")
         
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  
     # calculation of sd for prediction
     #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  

     #~~~~~~~~~~~~~~~~~~~~~~~~~
     # between sample covariance
     #~~~~~~~~~~~~~~~~~~~~~~~~~
    
    # v <- VarCorr(REF)
    # vars <- as.numeric(as.vector(v[(grep("Residual", rownames(v), invert=TRUE)),"Variance"]) )
    # r = as.numeric(v[,"Corr"])
    # r = r[!is.na(r)]
    # covars <- prod(sqrt(vars)*r)##
    # vc <- matrix(c(vars[1],covars, covars, vars[2]),nrow=2,ncol=2,byrow=TRUE)
    
    #~~~~~~~~~~~~~~~~~~~~~~~
    # v <- VarCorr(REF)
    # corMatrix(as.numeric(v[,"Corr"]))
    
    #https://rstudio-pubs-static.s3.amazonaws.com/5374_04621aa8517e488e8d532e56cf636469.html
    r <- cov2cor(getVarCov(REF))
    b <- getVarCov(REF)
    
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # within variance covariance!!
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    # https://stat.ethz.ch/pipermail/r-sig-mixed-models/2009q3/002759.html
    # as.numeric(REF$sigma*coef(REF$modelStruct$varStruct, unconstrained=FALSE, allCoef=TRUE))
    # https://stats.oarc.ucla.edu/r/examples/alda/r-applied-longitudinal-data-analysis-ch-7/
    # r <- corMatrix(REF$modelStruct$corStruct)[[5]]

    # this function does it
    
    corandcov <- function(REF,cov=T,...){
      
      corm <- corMatrix(REF$modelStruct$corStruct)[[5]]  # corr matrix
      #print(corm)
      varstruct <- (REF$modelStruct$varStruct)  ## ratio of SDs
     # print(varstruct)
      varests <- coef(varstruct, uncons=F, allCoef=T) # ratio of SDs again
      covm <- corm*REF$sigma^2*t(t(varests))%*%t(varests)
      
    return(covm)
      }

    w <- corandcov(REF)
    
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # overall
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    o <-  w+b              # overall w+b
    
    # Standard deviation of the differences can be computed accordingly ..var of diff equals var of sum -2 x covariance
    vdiff <-  sum(diag(o)) - 2*o[1,2] 
    sd.pred <- sqrt(vdiff)  # SD
    
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # models to test against reference model
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    NMB = lme(y ~ meth,
        data = foo,
        random = list(item=pdCompSymm(~ meth-1)),
        weights=varIdent(form=~1|meth),
        correlation = corSymm(form=~1 | item/repl),
        method="ML")
        
    NMW = lme(y ~ meth,
        data = foo,
        random = list(item=pdSymm(~ meth-1)),
        #weights=varIdent(form=~1|meth),
        correlation = corCompSymm(form=~1 | item/repl),
        method="ML")
   
    NMO = lme(y ~ meth,
        data = foo,
        random = list(item=pdCompSymm(~ meth-1)),
        #weights=varIdent(form=~1|meth),
        correlation = corCompSymm(form=~1 | item/repl),
        method="ML")

  # Test the hypothesis that both methods have equal between-subject variances 
  RB <- anova(REF, NMB)
  # Test the hypothesis that both methods have equal within-subject variances
  RW <- anova(REF, NMW)
  # A test for equality of overall variances.
  RO <- anova(REF, NMO)
    
  return(list(REF=REF, NMB=NMB, NMW=NMW, NMO=NMO, sd.pred=sd.pred , RB=RB, RW=RW, RO=RO))
  
  })
  
  
  
  
  
  
  
  
  
  
  
  

```


### Boxplots 
 
 
```{r mcomp2.4}

 renderPlot({
 
    d <- r1_2()$foo
    
    xx <- random.sample_2()       # bring in methods to plot
    wh.comp=c(xx$mz[2], xx$mz[3]) # bring in 2 methods
 
    d$meth <- as.numeric(as.character(d$meth)) # make numeric to add some jitter
    
    d <- d[d$meth %in% wh.comp,]   # subset so there are two methods using usede inputs

    d$xj <- jitter( d$meth, amount=.13)  # jitter
    
    d$grp <- paste(d$item, d$repl, sep=".") # this is need for plot

    # code based on count app
    AA <- ggplot(data=d, aes(y=y) ) +
      geom_boxplot(aes(x=meth, group=meth), width=0.2, outlier.shape = NA, col='blue', fill='lightblue') +
      geom_line(aes(x=xj, group=grp),  colour=d$grp, alpha=.5) +
      geom_point(aes(x=xj), size=2,  colour=d$repl) +
      xlab("Method [dots indicate reps, items by coloured lines] - this presentation is not that useful") + ylab("y") +  
      scale_x_continuous(breaks=wh.comp ) +
      theme_bw() + theme(legend.position = "none") 
  
    print(AA)
    
})



  
```

### Permute the reps
 
 
```{r mcomp2.5}

cat("Replicates within samples within methods are permuted, this therefore evaluates the exchangability assumption, if the replicates are linked  this should make a difference to limits")

 renderPlot({
     plot(main="", perm.repl(r1_2()$foo))
  })

```

### Analyse as if no replication?

```{r mcomp2.6}


renderPlot({
  
  
     d <- r1_2()$foo
     w <- to.wide(d)
     
    xx <- random.sample_2()       # bring in methods to plot
    wh.comp=c(xx$mz[2], xx$mz[3]) # bring in 2 methods
 
    
     library(dplyr)
     A <-  w %>% pull(as.character(wh.comp[1]))
     B <-  w %>% pull(as.character(wh.comp[2]))
     
     n <- dim(w)[1]
    
    d <- data.frame(y = A , x = B)
  
    my_data <- data.frame( 
      group = rep(c(wh.comp[1], wh.comp[2]), each = n),
      counts = c(d[,1],  d[,2]),
      ID=rep(1:n,2)
    )
  
   m <- Meth(my_data,meth="group",item="ID",repl=NULL,y="counts",print=TRUE)
   
   L <- max(abs(floor(min(A-B))),abs(ceiling(max(A-B))))
   
   L <- roundUp(L)
    
    # we set up const dif and const sd so that will matches true data generating mechanism
    par( mfrow=c(1,1), mar=c(3,3,1,3), mgp=c(3,1,0)/1.6 )
   
    BA.plot( m, model=NULL, repl.conn=TRUE,  
             
              col.lines="gray60", 
   
        col.eqn = "black" ,
        font.eqn = 3,
             
             # axlim=c(0,20), 
            # diflim=c(-L,L), 
             xaxs="i", yaxs="i",
              col.points='blue',
             las=1, eqn=TRUE,   
             pl.type=input$Pl.typez, 
             sd.type=input$SD.type, 
             dif.type = input$Dif.type, # cons is simulatied
             grid=1:9*10, digits=3,
        #font.eqn=1  , 
        eqax=T, col.grid=gray(0.9))
    
if ( input$Pl.typez=="conv") abline(a=0, b=1,   lty=2, col = "purple", lwd=2)

})



  
```

### Const. sd assumption
 
 
```{r mcomp2.7}

 
 
  mixed.assump <- reactive({
 
   
  foo <- r1_2()$foo
     
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # code from my useful code, adjusted slightly

  BA <- DA.reg(foo, DA.slope = TRUE)

  a1<-as.data.frame(unlist(BA))
  #DA.slope.p<-a1[14,]
  #cons.sd.p.value<-a1[38,]
  
  res<-rbind(a1[14,], a1[38,])
  res<-as.matrix(res)
  
  rownames(res)<-c( 
                   "DA Slope P-value",
                   "P-value for Changing SD")
  
  colnames(res) <- c("Bland Altman Analysis")
 # print(res)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ## **Assess Bland Altman assumptions P-values for two hypotheses:**
  w <- to.wide(foo)
  ## assumptions do it yourself
  
  xx <- random.sample_2()       # bring in methods to plot
  wh.comp=c(xx$mz[2], xx$mz[3]) # bring in 2 methods
 
    
  library(dplyr)
  A <-  w %>% pull(as.character(wh.comp[1]))
  B <-  w %>% pull(as.character(wh.comp[2]))
 
  w$y <-   A-B
  
  w$x <-  (B + A) /2
  
  # Constant difference - this is the test of 0 slope in the regression of differences on averages.
  f <- summary(lm(y~x, w))
  con.diff <- f$coefficients["x","Pr(>|t|)"]
  
  
  # Constant variance - this is the test of 0 slope in the regression of absolute residuals on averages.
 # w$r <- abs(residuals(f) ) # if you dont use abs the regression line slope will be 0!
  
  
  sel <- which(!is.na(w$y))
  w$r <- NA
  w$r[sel] <- abs(residuals(f) )
  
  # w$r <- (residuals(f) )
  # plot(r~x,w)
  f1 <- summary(lm(r~x, w))
  con.sd <- f1$coefficients["x","Pr(>|t|)"]
  
  return(list( con.diff=con.diff, con.sd=con.sd , w=w ))
  

})

renderPlot({
  
w <- mixed.assump()$w
con.sd <- mixed.assump()$con.sd
  
  ggplot(w, aes(x=x, y=r))+
    geom_point() +  
    geom_smooth(method="lm", col="black")  +
    stat_regline_equation(label.x = min(w$x), label.y = max(w$r))+
    theme_bw() +
    labs(title = paste0("First regressing the differences on the averages and then regressing the absolute residuals from this on the averages. This ignores the technical replication.\nTesting hypothesis slope=0, p=", formatz3(con.sd)),
         x = "Averages",
         y = "Absolute residuals")
   
})



  
```

### Const. diff. assumption
 
 
```{r mcomp2.8}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

renderPlot({
  
w <- mixed.assump()$w
con.diff <- mixed.assump()$con.diff

  xx <- random.sample_2()       # bring in methods to plot
  wh.comp=c(xx$mz[2], xx$mz[3]) # bring in 2 methods
 

  ggplot(w, aes(x=x, y=y))+
    geom_point() +  
    geom_smooth(method="lm", col="black")  +
    stat_regline_equation(label.x = min(w$x), label.y = max(w$r))+
    theme_bw() +
    labs(title = paste0("Regression of differences on averages. This ignores the technical replication.\nTesting hypothesis slope=0, p=", formatz3(con.diff)),
         x = "Averages",
         y = paste0("(",wh.comp[1] ," - ",wh.comp[2],")")
         )

})









```

### Data Listing

```{r mcomp2.1}

# not used yet

    Listing <- reactive({
  
      foo <- r1_2()$foo
      
           w <- to.wide(foo)
        
          #separate by replicate and merge together
         # r1<-w[w$repl==1,]
       #   r2<-w[w$repl==2,]
          
     #     w2<-merge(r1,r2, by.x="item", by.y="item")
        
    return(list(w=w ))
          
     })



  renderPrint({
  
    w <- Listing()$w
    rownames(w) <- NULL  # refressh rownames
    print(w)
    
 
  })

 

```
 
 
```{r texts} 

  # --------------------------------------------------------------------------
output$text2z <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "If the variables are uncorrelated the variance of the difference is equal to the sum of the variances. If there is any correlation this information is incorporated: ")))
  
})
  # --------------------------------------------------------------------------

output$text2az <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "The following is the covariance between the two variables. Add 2 x this if we are interested in the variance of the sum, for the variance of the difference subtract 2 x this component. ")))
  
})
   # --------------------------------------------------------------------------
   

output$text3z <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "A method comparison with ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", input$n_2) ,
   
     tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               " samples assayed on each of two methods. There is a true difference (after - before) of ") 
      
      , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", input$eff.p_2) ,
     
     
        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
     
    ", also there is a true correlation between the paired results of ")
    
      , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", input$r_2) ,
    
    
        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
    
    " and between sample SD commmon to both methods of ")
    
      , tags$span(style="color:blue ;font-weight:bold;font-size: 20px;", input$sd._2) ,
    
     tags$span(style="color:black;font-weight:bold;font-size: 20px;",
               
    ". By design the SD is constant across the range of values. Think of this SD component as the between person SD. Increase it to see the range of scores increase. We are not particularly interested in the between sample SD, this depends on the samples we choose and it is advisable to select samples that span range of the devices if possible. There are no technical replicates ", #),
    
    
        ".") ))
  # --------------------------------------------------------------------------
 })
 

output$text4z <- renderText({  # create interactive text t1

    print(paste0(   

        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "Based on the true parameters, the variance of the difference, calculated using the above equation, is ") 
    
         , tags$span(style="color:blue ;font-weight:bold;font-size: 20px;",formatz1( r1_2()$true )),
                     
                     tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
    
     ", this equates to an SD of the differences of ") 
    
       , tags$span(style="color:blue ;font-weight:bold;font-size: 20px;", formatz3(sqrt(r1_2()$true))) ,
    
     tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               ". The estimate from a simulated experiment is ") 
    
     , tags$span(style="color:blue ;font-weight:bold;font-size: 20px;", formatz3( r1_2()$est )),
                 
                  tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
    
        ", this equates to an SD of the differences of ")
    
     , tags$span(style="color:blue ;font-weight:bold;font-size: 20px;", formatz3( sqrt(r1_2()$est)),
    
                 ##add some more text
                  tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
    
        ", this matches the methComp estimate with the default settings, see the estimate in brackets in the Bland Altman plot top right"),".") ))

 })


output$text4az <- renderText({  # create interactive text t1

    print(paste0(   

        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
          
     "Notice there are no technical replicates per sample on each method. The repeatability of each method therefore cannot be estimated, this is a deficiency in the experimental design. Explore the other tabs to see a better design approach using technical replication!")) )

 })
  # --------------------------------------------------------------------------
 


```

Method Comp. listing
===

Column {.sidebar data-width=380}
-----------------------------------------------------------------------

**Design your method comparison, replication! **

```{r mc2B}
 
 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# orange button

  actionButton("resample_2B",   "Hit to simulate a new sample", style = "width:100%;")

 
       
   tags$style(HTML('#resample_2B{background-color:orange}'))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
output$text.reg.notes2B <- renderText({  # create text

    print(paste0(   

        tags$span(style="color:blue;font-size: 15px;", 
          
     "In the methods box the first entry is the no. of methods (try changing the 3 to 2!). The following are those that are presented in the the figures!")) )

 })

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  h5(htmlOutput("text.reg.notes2B"))    
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 splitLayout(
       textInput('methodzB', 
          strong(div(h5(tags$span(style="color:blue", 
            "No of methods")))), "2"),
       
 textInput('samplezB', 
           strong(div(h5(tags$span(style="color:blue", 
             "No of samples")))), "10"),
 
textInput('repzB', 
          strong(div(h5(tags$span(style="color:blue", 
           "Reps")))), "2,1")
                           )

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
output$text.reg.notesB <- renderText({  # create text
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    print(paste0(   

        tags$span(style="color:blue;font-size: 15px;", 
          
     "Vectors of method-specific intercepts and slopes for the linear equation relating the 'true' underlying sample mean measurement to the mean measurement on each method")) )

 })

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  h5(htmlOutput("text.reg.notesB"))    

 splitLayout(
    textInput('alphazB', 
              strong(div(h5(tags$span(style="color:blue", 
            "alphas")))), "0, 0.4, 0"),
    
    textInput('betazB', 
              strong(div(h5(tags$span(style="color:blue", 
              "betas")))), "1,1,1")
)
 
  
  textInput('sigma.mizB', 
            strong(div(h5(tags$span(style="color:blue", 
              "sigma.mi produces 'MxI' Method-specific shift\u03C3s for a method by sample random effect. Some or all components can be zero.")))), "0.062,0.04, 0.05")

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  textInput('sigma.irzB', 
            strong(div(h5(tags$span(style="color:blue", 
              "sigma.ir produces 'IxR' specific shift \u03C3s for the sample by replicate random effect. Only one can be estimated, if >0 this means reps are linked! The minimum reps (above box) only come into play if this is zero!")))), "0.05")
# 0.02,0.03, 0.05
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


  textInput('sigma.mirzB', 
            strong(div(h5(tags$span(style="color:blue", 
              "sigma.mir 'res' produces replicate shift \u03C3s for a method by sample by replicate random effect (residual variation). All components must be greater than zero.")))), "0.128,0.143, 0.222")
 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  textInput('mu.rangezB', 
            strong(div(h5(tags$span(style="color:blue", 
              "The range across items of the 'true' mean measurement. Sample means are uniformly spaced across the range. ")))), "-0.5 ,1")
 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  # textInput('mizzB', 
  #           strong(div(h5(tags$span(style="color:blue", 
  #            "Fraction of the observations from each method to keep, fraction of the observations from each sample to keep")))), "1 ,1")
  # 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  # selectInput("Pl.typezB", 
  #             strong(div(h5(tags$span(style="color:blue",
  #             "Select plot type (main top left)")))),  choices = c("BA", "conv"), selected="BA")
  #   
  # selectInput("modelzB", 
  #               strong(div(h5(tags$span(style="color:blue",
  #             "Model: replicates exchangable or linked?")))),  
  #             choices = c("exch", "linked"), selected="exch")
  
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  

```

...have fun...

Row {data-height=650}
-------------------------------------

### Listing (design, parameters, realisation and y)

```{r mc2B D}
 
   

 random.sample_2B <- reactive({
      
    # Dummy line to trigger off button-press
    foo <- input$resample_2B
    
   nz <-     as.numeric(unlist(strsplit(input$samplezB,   ",")))
   mz <-     as.numeric(unlist(strsplit(input$methodzB,   ",")))
   az <-     as.numeric(unlist(strsplit(input$alphazB,    ",")))
   bz <-     as.numeric(unlist(strsplit(input$betazB,     ",")))
   rz <-     as.numeric(unlist(strsplit(input$repzB,      ",")))
   miz <-    as.numeric(unlist(strsplit(input$sigma.mizB, ",")))
   irz <-    as.numeric(unlist(strsplit(input$sigma.irzB, ","))) # item x replicate
   mirz <-   as.numeric(unlist(strsplit(input$sigma.mirzB,",")))
   rangez <- as.numeric(unlist(strsplit(input$mu.rangezB,",")))
  # mizz <-   as.numeric(unlist(strsplit(input$mizzB,      ",")))
   irz=irz[1]
   
   
  #test data
  # mz=methodz=c(3,1,2)
  # nz=samplez=20
  # rz=repz =c(2,1)
  # az=alphaz=c(0,0.4,0)
  # bz=betas=c(1,1,1)
  # irz=sigma.irz=c(0.0)
  # miz=sigma.miz=c(0.062,0.062, 0.05)
  # mirz=sigma.mirz=c(0.128,0.143, 0.222)
  # rangez =mu.rangez=c(-0.5 ,1)
  # mizz=c(1 ,1)
  # modelz="exch"
  # #   
   
  # foo <- Meth.sim(Ni=nz[1] , 
  #                  Nm=mz[1],
  #               
  #               Nr=rz[1], 
  #               nr=rz[2],
  #               alpha=az, 
  #               beta= bz,
  #               
  #               m.thin=mizz[1], 
  #               i.thin=mizz[2],
  #               
  #               sigma.mi=miz, 
  #               sigma.ir=irz, 
  #               sigma.mir=mirz , 
  #               
  #               mu.range=rangez
  #               )
  
  
  # break down Meth.sim for more detail on listing
  
   
  
  Ni <- nz
  
  Nm = mz[1] # methods , fix this
  Nr = rz[1]# reps pre sample , fix this
  nr = rz[2]
  alpha = az #rep(a, Nm)
  beta =  bz #rep(b, Nm)
  mu.range =rangez    #  this will influence mean, the middle of this and correlation
  sigma.mi = miz #rep(btw,Nm)
  sigma.ir = irz
  sigma.mir = mirz#  rep(res, Nm)
   
  
  meth <- rep(1:Nm, Ni)   # methods 1:2 
  item <- rep(1:Ni, each = Nm)  ## 1 1 2 2 # samples 
  reps <- rep(Nr, length(meth))   # all 1s here
    
  dfr <- data.frame(meth = meth, item = item)[rep(1:length(meth), reps), ]
  dfr <- MethComp::make.repl(dfr)    # all 1
  
  meth <- dfr$meth
  item <- dfr$item
  repl <- dfr$repl

  # now we have the structure
  
  mu <- runif(Ni, mu.range[1], mu.range[2])  # true means of samples
  mu <- mu[item]
  

  # this will be 0
  # Item x replicate, Bendix says nothing to do with methods
  e.ir <- rnorm(nlevels(IR <- interaction(item, repl)), mean = 0, sd = sigma.ir)
  e.ir <- e.ir[as.integer(IR)]
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  e.mi <- rnorm(nlevels(MI <- interaction(meth, item)), mean = 0, sd = sigma.mi)
  e.mi <- e.mi[as.integer(MI)]
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  e.mir <- rnorm(nrow(dfr), mean = 0, sd = sigma.mir[meth])
  
  
  betavec <- beta[meth]
  alphavec <- alpha[meth]
  
  y <- alphavec + betavec * (mu + e.mi + e.ir) + e.mir
  
  # this is all that is needed
  # this is all that is needed
#  dfr1 <- dfr <- data.frame(dfr, y = y)
  
  #d1 <- Meth(dfr)
  
  # analysis
 # if (Nr ==1) (m<-BA.plot(d1, eqn=TRUE)) 
#  if (Nr >1 & sigma.ir >0 ) m <- BA.est(d1, linked=TRUE)
#  if (Nr >1 & sigma.ir ==0 ) M <- BA.est(d1, linked=FALSE)
  
  
  # lets get a dataset with true sds etc
   dfr <- data.frame(dfr )
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # shifts from mu and true parametrer
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ##
  dfr$alpha <- alphavec
  dfr$beta <- betavec
  
  
  # put variance components in dfr too!
  dfr$ sigma.mi  <-  sigma.mi[meth]
  dfr$ sigma.ir  <- sigma.ir 
  dfr$ sigma.mir <-  sigma.mir[meth]

  
  
  dfr$mu <- mu
  dfr$MI <- e.mi
  dfr$IR <- e.ir
  dfr$MIR <- e.mir

  dfr$y <- y
  
  #dfr <- data.frame(dfr, y = y)
  
  row.names(dfr) <- NULL
  head(dfr)
 
  foo <- dfr
  
 
   
   #BA.est(foo, linked=TRUE)
#    foo <- foo[ c("meth","item","repl","alpha","beta","sigma.ir","sigma.mi","sigma.mir","mu","IR","MI","MIR","y"), ]

  
  
  
        
    return(list(foo=foo, miz=miz, irz=irz, mirz=mirz, mz=mz))
     })



  r1_2B <- reactive({
 
   sample <- random.sample_2B()
    
   nz <-     as.numeric(unlist(strsplit(input$samplezB,   ",")))
   mz <-     as.numeric(unlist(strsplit(input$methodzB,   ",")))
   az <-     as.numeric(unlist(strsplit(input$alphazB,    ",")))
   bz <-     as.numeric(unlist(strsplit(input$betazB,     ",")))
   rz <-     as.numeric(unlist(strsplit(input$repzB,      ",")))
   
   miz <-    sample$miz  # the sds
   irz <-    sample$irz
   mirz <-   sample$mirz
   
   rangez <- as.numeric(unlist(strsplit(input$mu.rangezB, ",")))
 #  mizz <-   as.numeric(unlist(strsplit(input$mizzB,      ",")))
    
    # repeat the data generation the sds will produce fresh data
 
  
  
  
  Ni <- nz
  
  Nm = mz[1] # methods , fix this
  Nr = rz[1]# reps pre sample , fix this
  nr = rz[2]
  alpha = az #rep(a, Nm)
  beta =  bz #rep(b, Nm)
  mu.range =rangez    #  this will influence mean, the middle of this and correlation
  sigma.mi = miz #rep(btw,Nm)
  sigma.ir = irz
  sigma.mir = mirz#  rep(res, Nm)
   
  
  meth <- rep(1:Nm, Ni)   # methods 1:2 
  item <- rep(1:Ni, each = Nm)  ## 1 1 2 2 # samples 
  reps <- rep(Nr, length(meth))   # all 1s here
    
  dfr <- data.frame(meth = meth, item = item)[rep(1:length(meth), reps), ]
  dfr <- MethComp::make.repl(dfr)    # all 1
  
  meth <- dfr$meth
  item <- dfr$item
  repl <- dfr$repl

  # now we have the structure
  
  mu <- runif(Ni, mu.range[1], mu.range[2])  # true means of samples
  mu <- mu[item]
  

  # this will be 0
  # Item x replicate, Bendix says nothing to do with methods
  e.ir <- rnorm(nlevels(IR <- interaction(item, repl)), mean = 0, sd = sigma.ir)
  e.ir <- e.ir[as.integer(IR)]
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  e.mi <- rnorm(nlevels(MI <- interaction(meth, item)), mean = 0, sd = sigma.mi)
  e.mi <- e.mi[as.integer(MI)]
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  e.mir <- rnorm(nrow(dfr), mean = 0, sd = sigma.mir[meth])
  
  
  betavec <- beta[meth]
  alphavec <- alpha[meth]
  
  y <- alphavec + betavec * (mu + e.mi + e.ir) + e.mir
  
  # this is all that is needed
#  dfr1 <- dfr <- data.frame(dfr, y = y)
  
  #d1 <- Meth(dfr)
  
  # analysis
 # if (Nr ==1) (m<-BA.plot(d1, eqn=TRUE)) 
#  if (Nr >1 & sigma.ir >0 ) m <- BA.est(d1, linked=TRUE)
#  if (Nr >1 & sigma.ir ==0 ) M <- BA.est(d1, linked=FALSE)
  
  
  # lets get a dataset with true sds etc
   dfr <- data.frame(dfr )
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # shifts from mu and true parametrer
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ##
  dfr$alpha <- alphavec
  dfr$beta <- betavec
  
  
  # put variance components in dfr too!
  
  dfr$ sigma.mi  <-  sigma.mi[meth]
  dfr$ sigma.ir  <- sigma.ir 
  dfr$ sigma.mir <-  sigma.mir[meth]

  
  
  dfr$mu <- mu
  dfr$MI <- e.mi
  dfr$IR <- e.ir
  dfr$MIR <- e.mir

  dfr$y <- y

  
  #dfr <- data.frame(dfr, y = y)
  
  row.names(dfr) <- NULL
  head(dfr)
 
  foo <- dfr
  
 
   #    foo <- foo[ c("meth","item","repl","alpha","beta","sigma.ir","sigma.mi","sigma.mir","mu","IR","MI","MIR","y"), ]


 return(list( foo=foo ))
     
  })


options(width = 300)

# 
# 
 renderPrint({
 
  foo <- r1_2B()$foo

  ##
  
  
  
     print(foo)
   
   
   })
#   
# 
# 
 
```

Row {data-height=350}
-------------------------------------

### Explanation
 


```{r xxx}


h5(htmlOutput("e99"))   
h5(htmlOutput("e102")) 
h5(htmlOutput("e99a"))
h5(htmlOutput("e100")) 
h5(htmlOutput("e99b"))
h5(htmlOutput("e101"))   
 

output$e99 <- renderText({  # create interactive text t1

    print(paste0(   

        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
          
     "The listing includes the design matrix, the true population parameters, realisations from the normally distributed population sd parameters and the eventual response y.")) )

 })



output$e99a <- renderText({  # create interactive text t1

    print(paste0(   

        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
          
     "mu is the true sample values.")) )

 })

output$e99b <- renderText({  # create interactive text t1

    print(paste0(   

        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
          
     "IR is the item x replicate component, this is a shift based on realisations from a normal distributed component sigma.ir. This is only for a linked experiment, for example the same items replicates receive the same shift regardless of method. So this component has nothing to do with the methods.")) )

 })


output$e100 <- renderText({  # create interactive text t1

    print(paste0(   

        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
          
     "MI is the method x item component, you can see it affects the same method items which receive a shift, a realisation from a method specific sd, namely sigma.mi")) )

 })

output$e101 <- renderText({  # create interactive text t1

    print(paste0(   

        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
          
     "MIR is the method x item x rep component, repeatability or residual you can see it affects each replicate which receive a realisation from a method specific sigma.mir normal distribution")) )

 })


output$e102 <- renderText({  # create interactive text t1

    print(paste0(   

        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
          
     "y <- alpha + beta * (mu + MI + IR) + MIR")) )

 })

 


```

### Explanation2

Row {data-width=200}
-------------------------------------


```{r xxxx}

  
``` 
 

T-test 
====

Column {.sidebar}
-----------------------------------------------------------------------

Here we define the parameters of a lognormal distribution and a proportional change (independent groups)

```{r, main power tab2}
 
    
      div(h5(tags$span(style="color:blue", "Enter true population values:")))

      textInput("v3", div(h5(tags$span(style="color:blue", "Sample size per arm"))),     value= "60")
      textInput("v1", div(h5(tags$span(style="color:blue", "Log Normal mean"))),     value= "100")
      textInput("v2", div(h5(tags$span(style="color:blue", "Log Normal SD"))),      value= "50")
      textInput("v4", div(h5(tags$span(style="color:blue", "Confidence Level"))),    value= "0.90")
      textInput("v5", div(h5(tags$span(style="color:blue", "QC Level"))),            value= "0.85")
      textInput("v6", div(h5(tags$span(style="color:blue", "Proportional change"))), value= "0.95")
      
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   # orange button
   actionButton("resampley",   "Hit to simulate a new sample")
      
   #  tags$head(
   tags$style(HTML('#resampley{background-color:orange}'))
   # )
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
       
# try these means and sds
# 0.3  0.08
# 0.19 0.15 
# 0.42 0.32
# 0.96 0.1
# 0.9  0.09
       
      
 output$text55 <- renderText({  # create interactive text t1

    print(paste0(   
    
       tags$span(style="color:black;font-weight:bold;font-size: 20px;",  "To meet the QC level of ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", random.sample2()$qc )
    
     , tags$span(style="color:black;font-weight:bold;font-size: 20px;",  " means the entire ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;",  random.sample2()$conf*100 )
     
     , tags$span(style="color:black;font-weight:bold;font-size: 20px;", " % confidence interval of the contrast must lie within ") 
     
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;",  random.sample2()$qc*100 )
                 
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;",   "/100" )
     
     , tags$span(style="color:black;font-weight:bold;font-size: 20px;",   " = " )
                 
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;",  random.sample2()$qc )  
                  
     , tags$span(style="color:black;font-weight:bold;font-size: 20px;",   " and " )
     
      , tags$span(style="color:blue;font-weight:bold;font-size: 20px;",   "100/" ) 
     
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;",  random.sample2()$qc*100 )  
                    
     , tags$span(style="color:black;font-weight:bold;font-size: 20px;",   " = " )
                  
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;",  formatz2(100/(random.sample2()$qc *100) )) 
   
  ))
   
})
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    h5(htmlOutput("text55"))   

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

```


```{r text power, eval=TRUE}

    random.sampley <- reactive({
      
     # Dummy line to trigger off button-press
     foo <- input$resampley
         
     a    <- as.numeric(eval(parse(text= (input$v2)) ) )  # the random component , only need this for button  
  
     return(list(a=a))
     
     })

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  random.sample2 <- reactive({

    sampley <- random.sampley()
    
    # writing like this I can write log and fraction into input boxes!
    mux  <- as.numeric(    eval(parse(text= (input$v1)) ) )
    #a    <- as.numeric(    eval(parse(text= (input$v2)) ) )  # sd 
    n    <- as.numeric(    eval(parse(text= (input$v3)) ) )
    conf <- as.numeric(    eval(parse(text= (input$v4)) ) )
    qc   <- as.numeric(    eval(parse(text= (input$v5)) ) )
    zx   <- as.numeric(    eval(parse(text= (input$v6)) ) )
    #normal_to_lognormal(normmean = mux, normsd = a)
    
    a <-    sampley$a # change with push of button
    
    v <- a^2
    m <- mux
    
    phi = sqrt(v + m^2);
    mu    = log(m^2/phi)          # mean of log(Y)     
    sigma = sqrt(log(phi^2/m^2))   # std dev of log(Y)  
      
    # feed normal distirbution parameters into this function:
    zz <- power.t.test(n=n, delta =log(zx), sd=sigma, sig.level=0.05,
                      # power=pow,
                       type="two.sample", alternative=c("two.sided"))
    
     
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # this duplicates my code
    #lognormal_to_normal(meanlog=mu, sdlog=sigma)
    
    v <- sigma^2
    logN.mu <- exp(mu+0.5* v)
    logN.SD <- logN.mu*sqrt(exp(v)-1)
    
    #------------------------------------------------------------------------------
    
    N <- ceiling(zz$n)
    sd    <- sigma
    delta <- log(zx)
    
    A <- lapply(1:N, function(i) rlnorm(1, meanlog=mu,       sdlog=sd))
    B <- lapply(1:N, function(i) rlnorm(1, meanlog=mu+delta, sdlog=sd))
    
    A <- unlist(A)
    B <- unlist(B)
    
    A.GM <- exp(mean(log(A)))
    B.GM <- exp(mean(log(B)))
    
    #------------------------------------------------------------------------------
        return(list(
          
         mu=mu, sd=sd, zz=zz, logN.mu=logN.mu, logN.SD=logN.SD, 
         delta=delta, A.GM=A.GM, B.GM=B.GM, zx=zx, A=A, B=B, N=N, conf=conf, qc=qc,  mux=mux
    
        ))
      })

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

```
 
Column {data-width=400, height=75}
-----------------------------------------------------------------------
 
   
### The top left panel are histograms on the original scale, the right, natural log transformed versions

```{r power typical barplot}

renderPlot({

  N <-        random.sample2()$N
  mu <-       random.sample2()$mu
  mux <-      random.sample2()$mux
  logN.mu <-  random.sample2()$logN.mu
  logN.SD<-   random.sample2()$logN.SD
  zx<-        random.sample2()$zx
  sd<-        random.sample2()$sd
 
  A<-         random.sample2()$A
  B<-         random.sample2()$B#
  A.GM<-      random.sample2()$A.GM
  B.GM<-      random.sample2()$B.GM
 
  delta <-   random.sample2()$delta
 
    # common limits for plotting
    lx <- floor(min(A, B))
    ux <- ceiling(max(A,B))
    
    llx <- floor(  min(log(A), log(B)))
    lux <- ceiling(max(log(A), log(B)))
  
  
    par(mfrow=c(2,2))
    
    x<-seq(-8+mu,+8+mu,by=0.02) # range of values to plot over
    
    br <- ifelse(N<100, N, 100) # bins in histograms
    
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    MASS::truehist(A, 
                  yaxt='n' ,
                  nbins=br,  axes=FALSE,  xlim=c(lx,ux),
    main=paste0("A. N=",N," realisations from log-normal mu=", formatz00(logN.mu),", SD=", formatz00(logN.SD),
                ", Sample Geometric Mean=",p3(A.GM)), col = "blue", 
                  border = "white", xlab="Original scale")
    #adding log normal curve, here the mean and sd of the transformed dist are entered
    curve(dlnorm(x, meanlog = mu, sdlog =sd, log = FALSE), add=TRUE)   
    Axis(side=1, labels=TRUE)
    Axis(side=2, labels=FALSE)
    
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    MASS::truehist(log(A),
                   yaxt='n' , 
                   nbins=br,  axes=FALSE,  xlim=c(llx,lux),
    main=paste0("A. N=",N," log transformed of left data, theoretical mu=", p3(mu),", SD=", p3(sd),
                ""), col = "blue", border = "white",  xlab="log scale")
    #adding normal curve, here the mean and sd of the transformed dist are entered, as above, just dist differs
    curve(dnorm(x,mu,sd), add=TRUE)           
    Axis(side=1, labels=TRUE)
    Axis(side=2, labels=FALSE)
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    MASS::truehist(B, 
                    yaxt='n' ,
                    nbins=br,  axes=FALSE, xlim=c(lx,ux),
    main=paste0("B. N=",N," realisations true log-normal mu=",formatz00(mux*zx),", SD=", formatz00(logN.SD), 
                ", sample Geometric Mean=",p3(B.GM) ,"\nTrue treatment effect ",mux*zx," / ",mux,"=",zx), 
                   col = "orange", border = "white", xlab="Original scale")
     
    curve(dlnorm(x, meanlog = mu+delta, sdlog =sd, log = FALSE), add=TRUE)  
    Axis(side=1, labels=TRUE)
    Axis(side=2, labels=FALSE)
    
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    MASS::truehist(log(B), 
                   yaxt='n' ,
                   nbins=br, axes=FALSE, xlim=c(llx,lux),
      main=paste0("B. N=",N," log transformed of left data, theoretical mu=", p3(mu+delta),", SD=",p3(sd), 
                  "\nTrue treatment effect ", p3(mu+delta)," - ",p3(mu),"=",
                               p3(log(zx))), col = "orange", border = "white", xlab="log scale" )
    
    curve(dnorm(x,mu+delta,sd), add=TRUE)
    Axis(side=1, labels=TRUE)
    Axis(side=2, labels=FALSE)
    
    par(mfrow=c(1,1))
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


})

 
```

Column {data-width=400}
-------------------------------------

### Boxplots on the original scale plus inferential calculations
  
```{r}  
  
  renderPlot({
  
    
  N <-  random.sample2()$N
  mu <-  random.sample2()$mu
  mux <-  random.sample2()$mux
  logN.mu <-  random.sample2()$logN.mu
  logN.SD<-  random.sample2()$logN.SD
  zx<-  random.sample2()$zx
  sd<-  random.sample2()$sd
 
  A<-  random.sample2()$A
  B<-  random.sample2()$B#
  A.GM<-  random.sample2()$A.GM
  B.GM<-  random.sample2()$B.GM
 
 
  delta <-  random.sample2()$delta
 
  conf    <- random.sample2()$conf
  qclevel <- random.sample2()$qc

  d <- data.frame(x =c(rep( "A" , N), rep( "B" , N)), y=c(A,B))
  
  res <- t.test(log(d$y)~d$x, var.equal = TRUE, conf.level=conf) # t test
  
  ci <- exp(-res$conf.int)
  hi <- round(ci[1],3)
  lo <- round(ci[2],3)
  
  qc <- ifelse(((qclevel<=lo) && (hi<=1/qclevel)), paste0("PASS spec. of ", qclevel), paste0("FAIL spec. of ", qclevel))
  GmeanR <- round(exp(res$estimate[1]),3) # geometric means
  GmeanT <- round(exp(res$estimate[2]),3) # geometric means
  
  # %CV get the sd of the logged data and exponenitate
  cv1 <-exp(tapply(log(d$y), d$x, sd))
  GmeanRcv <-  round((((cv1[1])-1)*100),3)
  GmeanTcv <-  round((((cv1[2])-1)*100),3)
  
  ratio. <- exp( (res$estimate)[2] - (res$estimate)[1])
  ratio. <- round(ratio.,3)
  
 # run a ggplot 
  d$Y <-  (d$y)  # choose response

gx <- ggplot(d, aes(x=x, y=Y)) +
  
  geom_point(aes(fill=x), size=3, shape=21, colour="grey20",
             position =position_jitter(width=.22, height=0))+
  
  geom_boxplot(outlier.colour=NA, fill=NA,colour="grey20") +
  
  
  scale_fill_manual(values = c(A = 'blue', 
                               B = 'orange')) + 
  scale_colour_manual(values = c(A = 'blue', 
                               B = 'orange'))+
  
  labs(title=paste0("QC=", qc)) + xlab("") + ylab("score") +
  labs(subtitle = 
         paste0("Geometric mean A=" ,GmeanR,"; %CV=",GmeanRcv,
                "\nGeometric mean B=" ,GmeanT,"; %CV=",GmeanTcv,
                "\nRatio B/A " ,ratio.,", ",conf*100,"%CI (",lo,", ",hi,")")) +
  
  annotate("text", x=0.5, y=max(d$y), label=paste0("n=", table(d$x)[1][[1]])) +
  annotate("text", x=1.5, y=max(d$y), label=paste0("n=", table(d$x)[2][[1]]))    +
  theme(legend.position="none") +
  guides(fill="none") +
  theme_bw() 
 
  print(gx)

  })
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 
```
  
### Boxplots of log transformed data, labelled with antilogs plus inferential calculations

```{r BApylot}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  renderPlot({
  
    
  N <-  random.sample2()$N
  mu <-  random.sample2()$mu
  mux <-  random.sample2()$mux
  logN.mu <-  random.sample2()$logN.mu
  logN.SD<-  random.sample2()$logN.SD
  zx<-  random.sample2()$zx
  sd<-  random.sample2()$sd
 
  A<-  random.sample2()$A
  B<-  random.sample2()$B#
  A.GM<-  random.sample2()$A.GM
  B.GM<-  random.sample2()$B.GM
 
 
  delta <-  random.sample2()$delta
 
  conf    <- random.sample2()$conf
  qclevel <- random.sample2()$qc
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##### log the response and use exponentiated ticks
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  d <- data.frame(x =c(rep( "A" , N), rep( "B" , N)), y=c(A,B))
  res <- t.test(log(d$y)~d$x, var.equal = TRUE, conf.level=conf) # t test

  ci <- exp(-res$conf.int)
  hi <- round(ci[1],3)
  lo <- round(ci[2],3)
  qc <- ifelse(((qclevel<=lo) && (hi<=1/qclevel)), paste0("PASS spec. of ", qclevel), paste0("FAIL spec. of ", qclevel))
  GmeanR <- round(exp(res$estimate[1]),3) # geometric means
  GmeanT <- round(exp(res$estimate[2]),3) # geometric means

  # %CV get the sd of the logged data and exponenitate
  cv1 <-exp(tapply(log(d$y), d$x, sd))
  GmeanRcv <-  round((((cv1[1])-1)*100),3)
  GmeanTcv <-  round((((cv1[2])-1)*100),3)

  ratio. <- exp( (res$estimate)[2] - (res$estimate)[1])
  ratio. <- round(ratio.,3)
 
   # now use the tick info on ggplot of log response
   d$Y <-  log(d$y)  # choose response
 
   # choose appropriate scale next scale bigger than max d$y
   scalez <- c(0.001, 0.01, .1 ,1, 10, 100, 1000, 10000, 1e5 , 1e6)
   top <-    min(which( max(d$y) < scalez))
   bottom <- max(which( min(d$y) > scalez))
   scalez <- scalez[bottom:top]
   
   ticks= log(scalez)
 
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   
   labs <- exp(ticks)  # exponentiate the labels
   
   g1 <- ggplot(d, aes(x=x, y=Y)) +
     geom_point(aes(fill=x), size=3, shape=21, colour="grey20",
                position =position_jitter(width=.22, height=0))+
     geom_boxplot(outlier.colour=NA, fill=NA,colour="grey20") +
  
       scale_fill_manual(values = c(A = 'blue', 
                               B = 'orange')) + 
  scale_colour_manual(values = c(A = 'blue', 
                               B = 'orange'))+
  
    scale_y_continuous(
      
     limits=c(   ticks[1],  ticks[length(ticks)]  ), 
        breaks= ticks,    # this is where the values go
        labels= labs) +   # these are labels
     
     labs(title=paste0("QC=", qc)) + xlab("") + ylab("score") +
     labs(subtitle = 
            paste0("Geometric mean A=" ,GmeanR,"; %CV=",GmeanRcv,
                   "\nGeometric mean B=" ,GmeanT,"; %CV=",GmeanTcv,
                   "\nRatio B/A " ,ratio.,", ",conf*100,"%CI (",lo,", ",hi,")")) +
     
     annotate("text", x=0.5, y=max(ticks), label=paste0("n=", table(d$x)[1][[1]])) +
     annotate("text", x=1.5, y=max(ticks), label=paste0("n=", table(d$x)[2][[1]]))    +
     theme(legend.position="none") +
     guides(fill="none") +
     theme_bw() 
   
   print(g1)
   
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   
    
  })
  
``` 


Anova (linear model) contrasts
====
 

Column {data-width=400}
-------------------------------------
  
### Plot on original scale
  
```{r left1, eval=TRUE}  


renderPlot({
  
   df <-  random.sample3()$dd
   
  yy <- ggplot(df, aes(reorder(IV,DV),DV,fill=IV))+

    stat_boxplot(geom ='errorbar',width = 0.4) +
    geom_boxplot(outlier.shape = NA) + #avoid duplication of outliers
    labs(title="Boxplot, dotplot and Standard error of mean for groups", 
         x = "Groups (sorted)",
         y = "Response",
         subtitle ="Blue dots=sample data points, Yellow dot=mean, Red=1 x standard error ",
         caption = "") +
    guides(fill="none") +
    
    geom_jitter(shape=21, fill="blue", color="darkred", size=3, width= 0.1) +
     
    stat_summary(fun.data = mean_se, geom = "errorbar", colour = "red", size = 1, width= 0.1)+
    stat_summary(geom="point", fun=base::mean, color="yellow",  size = 2) +
    theme_bw() 
    print(yy)
  
})


```
Column {data-width=400, height=75}
-----------------------------------------------------------------------
  
### Plots of natural log data with anti-log y-axis labels

```{r right2}

renderPlot({
  
   d <-  random.sample3()$dd
   
   df <-  random.sample3()$dd

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  scalez <- c(0.001, 0.01, .1 ,1, 10, 100, 1000, 10000, 1e5 , 1e6)
  top <-    min(which( max(d$DV) < scalez))
  bottom <- max(which( min(d$DV) > scalez))
  scalez <- scalez[bottom:top]
  ticks= log(scalez)
  labs <- exp(ticks)  # exponentiate the labels
  
  df$DV <- log(df$DV)
  
xx<-  ggplot(df, aes(reorder(IV,DV),DV,fill=IV))+
    
    stat_boxplot(geom ='errorbar',width = 0.4) +
    geom_boxplot(outlier.shape = NA) + #avoid duplication of outliers
    labs(title="Boxplot, dotplot and Standard error of mean for groups", 
         x = "Groups (sorted)",
         y = "Response",
         subtitle ="Blue dots=sample data points, Yellow dot=mean, Red=1 x standard error ",
         caption = "") +
    guides(fill="none") +
    
    scale_y_continuous(
      
      limits=c(   ticks[1],  ticks[length(ticks)]  ), 
      breaks= ticks,    # this is where the values go
      labels= labs) +   # these are labels
    
    geom_jitter(shape=21, fill="blue", color="darkred", size=3, width= 0.1) +
    
    stat_summary(fun.data = mean_se, geom = "errorbar", colour = "red", size = 1, width= 0.1)+
    stat_summary(geom="point", fun=base::mean, color="yellow",  size = 2) +
    theme_bw() 
 
print(xx)

})

```

Column {.sidebar}
-----------------------------------------------------------------------
  
**User inputs for 4 independent groups**

 
```{r}

      sliderInput("range1", 
                   "Select group sizes: randomly select using range or uniquely select:", 
                    min = 2, max = 5000, value = c(1000, 1000), ticks=FALSE) 
                            
      sliderInput("range2", 
                  "Select lognormal baseline group mean",  
                  min = 0.5, max = 40000, value = c(400),ticks=FALSE)
                            
      sliderInput("range3", 
    "Select true group standard deviations: randomly select using range or uniquely select", 
                  min = 20, max = 10000, value = c(1000, 1000), ticks=FALSE) 
      
      textInput("pr1", div(h5(tags$span(style="color:blue", "Prop Chg Grp B v Grp A"))), value= "2")
      textInput("pr2", div(h5(tags$span(style="color:blue", "Prop Chg Grp C v Grp A"))), value= "4")
      textInput("pr3", div(h5(tags$span(style="color:blue", "Prop Chg Grp D v Grp A"))), value= "8")
 
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   # orange button
   actionButton("resamplex",   "Hit to simulate a new sample")
      
   #  tags$head(
   tags$style(HTML('#resamplex{background-color:orange}'))
   # )
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   
   div(h5(tags$span(style="color:blue", "Enter a level followed by a comma and the level(s) to contrast, eg A,BCD. For example, let's evaluate this contrast,\nthe proportional change\n of B compared to A")))
   splitLayout(
    textInput("qq", div(h5(tags$span(style="color:blue", ""))), value= "B,A"),
    
    )

   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   
   output$text99 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "The design matrix for ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", inference()$i )
    
  ))
})
   
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       
   output$text100 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "The design matrix for ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", inference()$j )

  ))
})
   
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   
output$text101 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "The design matrix for the subtraction ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", inference()$i ) ,

                tags$span(style="color:black;font-weight:bold;font-size: 20px;", " - ") 
  
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", inference()$j )     
    
    ,   tags$span(style="color:black;font-weight:bold;font-size: 20px;", " with intercept added (aka weights) ") 
    
    
  ))
     
})
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


   output$text102 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "The betas ") 
      
  ))
})
    
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


      output$text103 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "The variance covariance matrix ") 
    
  ))
})
   
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
      output$text104 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "Matrix multiplication [X] [VARCOV] [X'] and take the square root to get se") 
    
  ))
}) 
      
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      
           output$text105 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "Multiply betas by weights and sum to get the contrast estimate!") 
    
  ))
}) 
      
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
           output$text106 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "Lower and upper limits (estimate +/- zcrit * se)") 
    
  ))
}) 
      
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           
          output$text107 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "Contrasts of levels with intercept") 
    
  ))
}) 
                 
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           
           output$text108 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "The contrast function as specified by user inputs") 
    
  ))
})                 
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


```

Column {data-width=400, height=75}
-----------------------------------------------------------------------
  
### rms package analysis and contrast function
  
```{r top}

 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 h5(htmlOutput("text5"))

 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  renderPrint({
  
    model <- inference()$f
    print(model)
  
  })

 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  h5(htmlOutput("text107"))
  
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   
  renderPrint({
  
    model <- inference()$x
    print(model)
  
  })
  
 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 h5(htmlOutput("text108"))
 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  renderPrint({
  
    model <- inference()$res1
    print(model,X =TRUE) #  print(res1, X=TRUE)
  
  })
  
 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


```

 
-------------------------------------
  
### Walking through the calculation steps for a contrast
  
```{r left1test, eval=TRUE}  
 
 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 h5(htmlOutput("text99"))

 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

renderPrint({

  model <- inference()$Xa
  print(model)

})

 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 h5(htmlOutput("text100"))

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

renderPrint({

  model <- inference()$Xb
  print(model)

})

 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 h5(htmlOutput("text101"))

 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

renderPrint({

  model <- inference()$X2
  print(model)

})

 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 h5(htmlOutput("text102"))

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  renderPrint({
  
    model <- inference()$betas
    print(model)
  
  })

 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 h5(htmlOutput("text103"))

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
  renderPrint({
  
    model <- inference()$var.cov
    print(model)
  
  })

 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 h5(htmlOutput("text105"))
 
 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


  renderPrint({
  
    model <- inference()$est
    print(model)
  
  })

 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 h5(htmlOutput("text104"))


 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   renderPrint({
  
    model <- inference()$se
    print(model)
  
  })

 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 h5(htmlOutput("text106"))
 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  renderPrint({
  
    model <- inference()$lower
    print(model)
  
  })

 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  renderPrint({
  
    model <- inference()$upper
    print(model)
  
  })

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

random.sample3 <- reactive({
        
        # Dummy line to trigger off button-press
        foo <- input$resamplex
        
        x1 <- input$range1[1]  # size
        x2 <- input$range1[2]
        x3 <- input$range2     # mean
        x5 <- input$range3[1]  # sd
        x6 <- input$range3[2]
        
        zx1 <- as.numeric( eval(parse(text= (input$pr1)) ) )
        zx2 <- as.numeric( eval(parse(text= (input$pr2)) ) )
        zx3 <- as.numeric( eval(parse(text= (input$pr3)) ) )
         
        delta1 <- log(zx1)
        delta2 <- log(zx2)
        delta3 <- log(zx3)
       
        top <-  4  # number of groups

    #----------------------------------------------------
    # seems that I need to use both c(x1,x2) c(x1:x2) so sample function works correctly

    if (x1==x2) {
      
      middle <-  sample(c(x1,x2),   top, replace=TRUE)    # choose top count between sliders 
      
    } else {
      
      middle <-  sample(c(x1:x2),   top, replace=TRUE)    #  
    }
    
    #----------------------------------------------------
    lower <-   x3# groups mean
    #----------------------------------------------------
    
    if (x5==x6) {
      
      replicates <-  sample(c(x5,x6),  top, replace=TRUE )   #group sds
      
    } else {
      
      replicates <-  sample(c(x5:x6),   top, replace=TRUE )   #grp sds
      
    }
    #----------------------------------------------------




temp <- rep(lower, top)
#-----------------------------------------------------------------------

  x <- matrix(data = NA, nrow = 4, ncol = 2, byrow = FALSE,
            dimnames = NULL)
 
 #transform to normal distributions
 for( i in 1:4) {
   x[i,] <- unlist(normal_to_lognormal(normmean=temp[i], normsd=replicates[i]))
   }
  
 # get the sds
 replicates <- x[,2]  
 
 x[1,1] -> mu  # intercept
 lower <- c(mu, mu+delta1, mu+delta2, mu+delta3)  # true means

#-----------------------
 
  Nj    <- sum(middle)                        # sum each group size 
  
  muJ   <- rep(lower, times=rep(middle))      # expand means by group sizes
  
  sds   <- rep(replicates, times=rep(middle)) # expand sd by group sizes
  
  grpnames <- LETTERS[1:4]
  
  IV <- factor( rep( grpnames, times=rep(middle) ) )
  
  d <- data.frame(IV=IV,
                  mu= muJ, 
                  sd= sds,
                  x=1
  )
  
  
  d$DV = rlnorm(d$x, meanlog=d$mu, sdlog = d$sd)  # create the response
  
  df <- as.data.frame(d)
  
  dd <- arrange(df, IV)    # sort and create for better order
  
  dd$x <- NULL
  
  # ddz <<- datadist(dd) ;    options(datadist='ddz')
  # f <- ols(log(DV) ~ IV, dd)

  return(list(dd=dd ))

})



# reported in text5

inference <- reactive({
        
    df <-  random.sample3()$dd
   
    ddz <<- datadist(df) ;    options(datadist='ddz')
    
    fit <- ols(log(DV) ~ IV, df)

    x0 <- summary(fit)
    x <-  exp(x0[,4]) # plain 
    
    
    # cc <- contrast(f, list(IV='B', IV='D'),
    #                   list(IV='A', IV='C'), 
    #          type='average',
    #          conf.int=.9)
    # 
    # 
    # exp(cc$Contrast)
        
   # ------------------------------------contrast
    
    # lt <- levels(df$IV)
   qq <-    input$qq
    
   i <- gsub("^(.*?),.*", "\\1", qq)  # pull out before comma
   j <- sub('.*,\\s*', '', qq)        # pull out after comma
    
    a =  list(IV= dput(strsplit(i, "")[[1]])   )
    b =  list(IV= dput(strsplit(j, "")[[1]])   )
   
   #-------------------------------------------------
   
   res1 <- contrast(fit, 
      
        a,
        b,
           
       conf.int=0.95,  #weights=table(df$IV),
                  type='average') 
  
   des.mat <-  print(res1, X=TRUE)
   
    estx <- exp(res1$Contrast[1][[1]])
    L <-    exp(res1$Lower[1][[1]])
    H <-    exp(res1$Upper[1][[1]])
    # ------------------------------------
 
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # let's do the manual contrast after examining Harrell's contract.rms
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
   
   conf.int = 0.95

    # choosing critical value either t or z 
    zcrit <- if (length(idf <- fit$df.residual)) 
      qt((1 + conf.int)/2, idf) else qnorm((1 + conf.int)/2)
  
    betas <- coef(fit)  # all model coefficients
     
    nrp <- num.intercepts(fit, "var")  # should be 1 for this simple case

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # design matrix
    pred <- function(d) {
          predict(fit, d, type = "x")
    }
    
    # left side
    da <- do.call("gendata", list(fit, factors = a, expand = TRUE)) # creates a df of levels of intrest
    xa <- pred(da)    # will give a design matrix
 
    # right side
    db <- do.call("gendata", list(fit, factors = b, expand = TRUE))
    xb <- pred(db)     # will give a design matrix
      
    ma <- nrow(xa)
    mb <- nrow(xb)
    
     mall <- c(ma, mb)
    
    # if you dont do this design matrices could be wrong
      mm <- max(mall)
    if (mm > 1 && any(mall == 1)) {
        if (ma == 1) 
            xa <- matrix(xa, nrow = mm, ncol = ncol(xa), byrow = TRUE)
        if (mb == 1) 
            xb <- matrix(xb, nrow = mm, ncol = ncol(xb), byrow = TRUE)
      
    }
 
     
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # design matrix difference
    X1 <-  X <- xa - xb  # subtract   X1 will be outputted for presentation
    
    m <- nrow(X)
    
    # binding column of zeros
    if (nrp > 0)  X <- cbind(matrix(0, nrow = m, ncol = nrp), X)

    weights <- rep(1, m)          ## 1 1
    weights <- as.vector(weights)  # 1 1
    
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    X2 <- X <- matrix(    # X2 will be outputted for presentation
        apply(weights * X, 2, sum)/sum(weights), 
                  nrow = 1, dimnames = list(NULL, dimnames(X)[[2]]))
     
      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~contrast
    
      X   # [1x4]  this is the weights!   #  0  0.5   -1  0.5
      
      # weight the betas and sum to get contrast
      est <- matxv(X, betas)   # contrast X %*% betas
      
      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~variance

      var.cov <- vcov(fit, regcoef.only = TRUE)   # 4X4

      v <- X %*% var.cov %*% t(X)  # variance!!   [1x4] x [4X4] x [4X1]
      
      ndf <- if (is.matrix(v))  nrow(v) else 1    # TRUE  #1
      
      se <- as.vector(if (ndf == 1) sqrt(v) else sqrt(diag(v))  )  
      
      Z <- est/se                                  # standard normal
      
      P <- if (length(idf)) 2 * pt(-abs(Z), idf)  else 2 * pnorm(-abs(Z))
      
      lower <- est - zcrit * se
      upper <- est + zcrit * se
  
    # printed on right tab  
    resxx <- list(Contrast = est, SE = se, Lower = lower, Upper = upper, 
                Z = Z, Pvalue = P,  
                var = v, 
                df.residual = idf, 
                X = X, 
               conf.int = conf.int
                 )
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # end manual contrast
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    
    
  return(list(
    
         res=estx , L=L, H=H, i=i, j=j, res1=res1,
         
         f=fit, x=x, des.mat=des.mat,
         
         resx=resxx,  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         
         Xa=xa, Xb=xb, weights=weights, X1=X1, X2=X2, betas=betas,
         var.cov=var.cov, est=est, se=se, lower=lower,
         
         upper=upper
              
              ))   
        
})


    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


```  

<!-- tab 6   -->
<!-- ==== -->

<!-- Column {.sidebar} -->
<!-- ----------------------------------------------------------------------- -->

<!-- xxxxxxxxxxxx -->

<!-- ```{r A, eval=TRUE} -->


<!-- ``` -->

<!-- Row {data-height=275} -->
<!-- ----------------------------------------------------------------------- -->

<!-- ### xxxxxxxxxxxxxxxx -->
  

<!-- ```{r B, eval=TRUE} -->


<!-- ``` -->

<!-- Row {data-height=250} -->
<!-- ----------------------------------------------------------------------- -->

<!-- ### xxxx -->


<!-- ```{r C, eval=TRUE} -->


<!-- ``` -->

   
<!-- Row {.tabset .tabset-fade} -->
<!-- ----------------------------------------------------------------------- -->

<!-- ### xxxx -->
  

<!-- ```{r D, eval=TRUE} -->


<!-- ``` -->

<!-- ### xxxx -->

<!-- ```{r E} -->


<!-- ``` -->


Wiki
====
 
<!-- x $\alpha$ x  -->
 

```{r}

  # --------------------------------------------------------------------------

output$text.wiki <- renderText({  # create interactive text t1

    print(paste0(   
 
           tags$span(style="color:black;font-weight:bold;font-size: 20px;",
               
    " Method comparison is presented on the first tab. A simple experiment in which any difference is constant across the range and the standard deviation is also constant and common to both methods. Correlation between samples analysed using both methods can be introduced. If methods agree we expect there to be positive correlation. That is, if one method measures a sample to have a high value we would expect the second method to have a similar high value. We present a plot of the data using boxplots and join the same sample with a thin line, beside it a simple scattterplot. Bottom right the default plot is the familiar Bland Altman plot with 95% limits of agreement and conversion equation. There is an option to show instead the inference on a scatter plot. There are user options too for the analysis, bottom left. Here, the difference can be analysed depending on the averages assuming it is constant (default) or linear. The standard deviation can be analysed depending on the averages assuming it is constant (default) or linear
    ", #),
    
        ".") ))
 })
 

  # --------------------------------------------------------------------------

output$text.wiki2 <- renderText({  # create interactive text t1

    print(paste0(   
  
    
     tags$span(style="color:black;font-weight:bold;font-size: 20px;",
               
    " Method comparison diagnostics are presented on the next tab. The diagnostics include a check of the assmptions of constant variance across the range and constant difference across the range. Below there are more tabs, the first two plots are repeated but with some small modifications (just for programming practice). There is also a tab including histogram of the differences
    ", #),
    
    
        ".") ))
 })
 
  # --------------------------------------------------------------------------

  # --------------------------------------------------------------------------

output$text.wiki3 <- renderText({  # create interactive text t1

    print(paste0(   
  
    
     tags$span(style="color:black;font-weight:bold;font-size: 20px;",
               
    " The T test example tab allows the user to define a lognormal distributed variable (mean, sd and sample size) and another lognormal distributed variable of the same sample size and sd but proportionally different as defined by the user input. There are also user inputs for the confidence level and QC level. At the top we plot in blue the A group on the original scale (left) and log transformed scale. The B group is plotted similarly. At the bottom we plot boxplots (remember this is unpaired data). Also there are inferential statistics above the boxplots
    ", #),
    
    
        ".") ))
 })

output$text.wiki4 <- renderText({  # create interactive text t1

    print(paste0(   
  
    
     tags$span(style="color:black;font-weight:bold;font-size: 20px;",
               
    " The Anova tab allows the user to define 4 lognormal distributed variables of user defined sample sizes, sds and proportional differences.  The idea behind this tab is to perform and understand contrasts. On the left is Frank Harrell's contrast function and on the right we step through how a contrast is calculated
    ", #),
    
    
        ".") ))
 })

output$text.wiki2do <- renderText({  # create interactive text t1

    print(paste0(   
  
    
     tags$span(style="color:black;font-weight:bold;font-size: 20px;",
               
    "  
      vickers code\n
      diagnostis for ANOVA\n
      reference\n
       pi/2 explanation\n
 gelmans book residuals\n
replicates\n
drop some reps\n
anova diagnostics\n
ttest diagnostics\n
    ", #),
    
    
        ".") ))
 })
 
 
  # --------------------------------------------------------------------------

  h5(htmlOutput("text.wiki"))

  h5(htmlOutput("text.wiki2"))
  
  h5(htmlOutput("text.wiki3"))
  
  h5(htmlOutput("text.wiki4"))

  h5(htmlOutput("text.wiki2do"))
  # --------------------------------------------------------------------------

    
```



References
====
```{r, refs}
 
    tags$a(href = "https://pubmed.ncbi.nlm.nih.gov/8337548/", target="_blank",
           tags$span(style="color:blue", "[1] Construction of age-related reference centiles using absolute residuals, Doug Altman shows how to model the SD"),) 
    div(p(" "))
    # tags$a(href = "https://stats.stackexchange.com/questions/27869/fitting-a-poisson-glm-mixed-model-with-a-random-slope-and-intercept",target="_blank",
    #        tags$span(style="color:blue", "[2] Mixed model Poisson"),)
    # div(p(" "))
    
    div(p(" "))
  tags$hr()                        

```