---
title: "Method Comparison and beyond" 
author: 
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: scroll
    social: menu
    source_code: embed
runtime: shiny
---
Method Comparison
===



```{r global, include=FALSE}

  rm(list=ls())

  set.seed(64453)
  #library(MASS)      # for correlated data generation
  library(flexdashboard)
  library(ggplot2)
  library(gridExtra)
  library(ggpubr)
  library(ggExtra)
  library(shiny)
  library(utf8)      # codes for Greek letters
  library(MethComp)
  library(gridExtra)
  library(tidyverse)
  library(plyr)
  library(rms)
  library(nlme)
  lwd.=3             # used when plotting
  
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # function to format decimals
  # https://stackoverflow.com/questions/3245862/format-numbers-to-significant-figures-nicely-in-r
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  p3 <- function(x) {formatC(x, format="f", digits=3)}
  
  formatz <- function(x){
    
    if (!is.na(x)  ) {
      
      formatC(signif(x,digits=5), digits=5,format="fg", flag="#",big.mark=",")
      
    }
    
  }
  
  formatz0 <- function(x){
    sprintf(x, fmt = '%s')  
  }
  formatz1 <- function(x){
    sprintf(x, fmt = '%#.1f')  
  }
  formatz2 <- function(x){
    sprintf(x, fmt = '%#.2f')  
  }
  formatz00 <- function(x){
    round(x,0) 
  }
  formatz3 <- function(x){
    sprintf(x, fmt = '%#.3f')  
  }
  formatz4 <- function(x){
    sprintf(x, fmt = '%#.4f')  
  }
  
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# function to generate cor data , see count app
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

mvrnorm <- function(n = 1, mu = 0, Sigma) {
  nvars <- nrow(Sigma)
  # nvars x n matrix of Normal(0, 1)
  nmls <- matrix(rnorm(n * nvars), nrow = nvars)
  # scale and correlate Normal(0, 1), "nmls", to Normal(0, Sigma) by matrix mult
  # with lower triangular of cholesky decomp of covariance matrix
  scaled_correlated_nmls <- t(chol(Sigma)) %*% nmls
  # shift to center around mus to get goal: Normal(mu, Sigma)
  samples <- mu + scaled_correlated_nmls
  # transpose so each variable is a column, not
  # a row, to match what MASS::mvrnorm() returns
  t(samples)
}
   
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 # https://stackoverflow.com/questions/6461209/how-to-round-up-to-the-nearest-10-or-100-or-x/6468532#6468532
 # nice function from link to round to selected value

  roundUp <- function(x,to=10)
  {
    to*(x%/%to + as.logical(x%%to))
  }
  
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# try these functions https://github.com/davidski/collector/blob/main/R/fit_distributions.R

# Given a set of parameters describing a lognormal distribution, return
# the parameters of the underlying normal distribution.

lognormal_to_normal <- function(meanlog, sdlog) {
  norm_mean <- exp(meanlog + sdlog^2 / 2)
  norm_sd <- sqrt( (exp(sdlog^2) - 1) * exp(2*meanlog + sdlog^2))
  list(mean = norm_mean, sd = norm_sd)
}

#' normal_to_lognormal(normmean = 20, normsd = 3)
normal_to_lognormal <- function(normmean=10, normsd=2) {
  phi <- sqrt(normsd ^ 2 + normmean ^ 2)
  lognorm_meanlog <- log(normmean ^ 2 / phi)
  lognorm_sdlog <- sqrt(log(phi ^ 2 / normmean ^ 2))
  list(meanlog = lognorm_meanlog, sdlog = lognorm_sdlog)
}

 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# start of app
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

```

Column {.sidebar}
-----------------------------------------------------------------------

**Design your method comparison, a simple setting, no replication **

```{r tab1}

 
 
  sliderInput('n', 'n pairs of data', value=100,
                min = 5, max = 1000, step=5, ticks=F)

  sliderInput('mu0', 'Initial mean  \u03BC', value=0,
                min = -100, max = 100, step=5, ticks=F)
  
  sliderInput('eff.p', 'Constant difference', value = c(0),
                min = -25, max = 25 ,step=1, ticks=F)
  
  sliderInput('sd.', 'Common constant \u03C3', 1,
                min = 1, max = 100, step=1,ticks=F)

  sliderInput('r', 'Correlation \u03C1', value = c(.8),
                min = -.9, max = .9, step=0.05, ticks=F)
  
  selectInput("SD.type", "Select \u03C3 type",          choices = c("cons", "lin"), selected="cons")
  
  selectInput("Dif.type", "Select difference type", choices = c("cons", "lin"), selected="cons")
  
  selectInput("Pl.type", "Select plot",             choices = c("BA", "conv"), selected="BA")
 
  
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   # orange button
   actionButton("resample",   "Hit to simulate a new sample")
      
   #  tags$head(
   tags$style(HTML('#resample{background-color:orange}'))
   # )
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 

```

The top two drop down menus allow different modelling approaches. Note, the default settings reflect the true data generating mechanism.

Column {data-width=400}
-------------------------------------

### Paired boxplots and scatter plot

```{r, tab1 plot3}

   # --------------------------------------------------------------------------
 

renderPlot({
  
  A <- r1()$pp1
  B <- r1()$pp2
  
  m <- ceiling(max(A,B))
  mL <- floor(min(A,B))
  before <- A  
  after <-  B  
  n <- length(before)
  d <- data.frame(y = c(before, after), 
                  x = rep(c(1,2), each=n),
                  id = factor(rep(1:n,2)))
  
  d$xj <- jitter(d$x, amount=.13)
  # code from count app
  AA <- ggplot(data=d, aes(y=y) ) +
    geom_boxplot(aes(x=x, group=x), width=0.2, outlier.shape = NA, col='blue', fill='lightblue') +
    geom_line(aes(x=xj, group=id),  colour='pink', alpha=.5) +
    geom_point(aes(x=xj), size=2) +
    xlab("Phase") + ylab("Count") +  
    scale_x_continuous(breaks=c(1,2), labels=c("Before", "After"), limits=c(0.5, 2.5)) +
   # scale_y_continuous(breaks=c(mL:m), limits=c(mL,m)) +
    theme_bw() + theme(legend.position = "none") 
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ scatter plot
  

  d <- data.frame(y = B , x = A)
  
  BB <- ggplot(d, aes(x, y)) +
    geom_jitter(width = 0.1, height = 0.1, size=2) +
   # scale_x_continuous(breaks=c(0:m), limits=c(mL,m)) +
   # scale_y_continuous(breaks=c(0:m), limits=c(mL,m)) +
    scale_x_continuous( limits=c(mL,m)) +
    scale_y_continuous(  limits=c(mL,m)) +
    xlab("Before count") +ylab("After count") +
    theme_bw() + theme(legend.position = "none") +
    geom_abline(intercept=0, slope=1)
  
  plot1 <- AA
  plot2 <- BB
  grid.arrange(plot1, plot2, ncol=2)


})
  # --------------------------------------------------------------------------


```

### Bland Altman plot with 95% limits of agreement, within which we expect 95% of the differences to lie.

```{r, tab1 plot4}

    
  # --------------------------------------------------------------------------


renderPlot({
  
    A <- r1()$pp1
    B <- r1()$pp2
    n <- input$n
    
    d <- data.frame(y = A , x = B)
  
    my_data <- data.frame( 
      group = rep(c("before", "after"), each = n),
      counts = c(d[,1],  d[,2]),
      ID=rep(1:n,2)
    )
  
   m <- Meth(my_data,meth="group",item="ID",repl=NULL,y="counts",print=TRUE)
   
   L <- max(abs(floor(min(A-B))),abs(ceiling(max(A-B))))
   
   L <- roundUp(L)
    
    # we set up const dif and const sd so that will matches true data genrting mechanism
    par( mfrow=c(1,1), mar=c(3,3,1,3), mgp=c(3,1,0)/1.6 )
   
    BA.plot( m, model=NULL, repl.conn=TRUE, col.lines="blue",
             # axlim=c(0,20), 
             diflim=c(-L,L), 
             xaxs="i", yaxs="i",
             las=1, eqn=TRUE,  
             pl.type=input$Pl.type, 
             sd.type=input$SD.type, 
             dif.type = input$Dif.type, # cons is simulatied
             grid=1:9*10, digits=3,font.eqn=1  , eqax=T)

})

  # --------------------------------------------------------------------------
 

```

Column {data-width=400, height=75}
-----------------------------------------------------------------------

### Introduction

```{r tab1 plot1}
 
   # --------------------------------------------------------------------------
    # I looked back to two period cross over trial to get this button working to resimulate
    # This is where a new sample is instigated only random noise is required to be generated
    random.sample <- reactive({
      
    # Dummy line to trigger off button-press
    foo <- input$resample
         
    L1 <-     input$mu0
    L2 <-     input$mu0+input$eff.p
    r  <-     input$r
    n <-      input$n
    sd. <-    input$sd.
    
# generate correlated poisson ref: https://thomasward.com/simulating-correlated-data/
# Sample correlated N(0, 1) distributions from a multivariate normal distribution.
# Transform them to correlated Uniform(0, 1) distributions with the normal CDF.
# Transform them to any correlated probability distribution you desire with that probability distribution’s inverse CDF.

    Sigma <- matrix(c(1, r, r, 1), 2, 2)

    px <- mvrnorm(n, Sigma = Sigma)   # correlated continuous, see function in global area!

    U <- pnorm(px, mean = 0, sd = 1)  # correlated uniform
    
    pp1 <- qnorm(U[, 1], L1, sd.)      # correlated normal  
    pp2 <- qnorm(U[, 2], L2, sd.) 
        
    return(list(pp1=pp1, pp2=pp2, sd.=sd.))
     })
   
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


  r1 <- reactive({
 
    sample <- random.sample()
     
     r  <-     input$r
     n <-      input$n
     sd. <-    sample$sd.  
 
     pp1 <- sample$pp1     # correlated normal  
     pp2 <- sample$pp2 
    
    cor. <- cor(pp1, pp2)              # capture correlation
 
    # create a data frame
    my_data <- data.frame( 
      group = rep(c("A.before", "B.after"), each = n),
      counts = c(pp1,  pp2),
      ID=rep(1:n,2)
    )

    ## variance of a difference from a simulation
    est <- var(pp1) + var(pp2) - 2 *cor. * sd(pp1) * sd(pp2)
    
    ## true variance of difference
    true <- sd.^2 + sd.^2 - 2 * r * sd. * sd.
    
    ## variance of a sum
    # var(pp1) + var(pp2) + 2 *cor. * sd(pp1) * sd(pp2)
    # 
    # 
    # sd.^2 +sd.^2 + 2 * r * sd.*sd.

 return(list( est=est, true=true , pp1=pp1, pp2=pp2 ))
     
  })
  
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  h5(htmlOutput("text3"))      ## print 
  
```


```{r, test}
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   # https://stackoverflow.com/questions/63507171/shiny-increase-mathjaxs-font-size
   # help on font size
   h5(htmlOutput("text2"))      
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                              withMathJax(
                                tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
                             helpText('
                             $${  
                             {\\sigma^2}{_{x \\pm y}} =  
                             {\\sigma^2}{_{x}}  +   {\\sigma^2}{_{y}} 
                             \\pm 2\\rho{\\sigma}{_{x}} {\\sigma}{_{y}}           
                             }\\!$$'
                             ))   
                             )
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   h5(htmlOutput("text2a"))   
     
                            withMathJax(
                               tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
                             helpText('
                              $${ 
                              \\rho {\\sigma}{_{x}}  {\\sigma}{_{y}}           
                              }\\!$$'))        
  
                            )
    # --------------------------------------------------------------------------
    h5(htmlOutput("text4"))   
    # --------------------------------------------------------------------------
    h5(htmlOutput("text4a"))   
    # --------------------------------------------------------------------------
```

 
```{r } 

  # --------------------------------------------------------------------------
output$text2 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "If the variables are uncorrelated the variance of the difference is equal to the sum of the variances. If there is any correlation this information is incorporated: ")))
  
})
  # --------------------------------------------------------------------------

output$text2a <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "The following is the covariance between the two variables. Add 2 x this if we are interested in the variance of the sum, for the variance of the difference subtract 2 x this component. ")))
  
})
   # --------------------------------------------------------------------------
   

output$text3 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "A method comparison with ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", input$n) ,
   
     tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               " samples assayed on each of two methods. There is a true difference (after - before) of ") 
      
      , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", input$eff.p) ,
     
     
        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
     
    ", also there is a true correlation between the paired results of ")
    
      , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", input$r) ,
    
    
        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
    
    " and between sample SD commmon to both methods of ")
    
      , tags$span(style="color:blue ;font-weight:bold;font-size: 20px;", input$sd.) ,
    
     tags$span(style="color:black;font-weight:bold;font-size: 20px;",
               
    ". By design the SD is constant across the range of values. Think of this SD component as the between person SD. Increase it to see the range of scores increase. We are not particularly interested in the between sample SD, this depends on the samples we choose and it is advisable to select samples that span range of the devices if possible. There are no technical replicates ", #),
    
    
        ".") ))
  # --------------------------------------------------------------------------
 })
 

output$text4 <- renderText({  # create interactive text t1

    print(paste0(   

        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "Based on the true parameters, the variance of the difference, calculated using the above equation, is ") 
    
         , tags$span(style="color:blue ;font-weight:bold;font-size: 20px;",formatz1( r1()$true )),
                     
                     tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
    
     ", this equates to an SD of the differences of ") 
    
       , tags$span(style="color:blue ;font-weight:bold;font-size: 20px;", formatz3(sqrt(r1()$true))) ,
    
     tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               ". The estimate from a simulated experiment is ") 
    
     , tags$span(style="color:blue ;font-weight:bold;font-size: 20px;", formatz3( r1()$est )),
                 
                  tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
    
        ", this equates to an SD of the differences of ")
    
     , tags$span(style="color:blue ;font-weight:bold;font-size: 20px;", formatz3( sqrt(r1()$est)),
    
                 ##add some more text
                  tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
    
        ", this matches the methComp estimate with the default settings, see the estimate in brackets in the Bland Altman plot top right"),".") ))

 })


output$text4a <- renderText({  # create interactive text t1

    print(paste0(   

        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
          
     "Notice there are no technical replicates per sample on each method. The repeatability of each method therefore cannot be estimated, this is a deficiency in the experimental design.")) )

 })




  # --------------------------------------------------------------------------

# see line 1412
 output$text5 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "After anti-logging, the contrast of ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", inference()$i )
    
     , tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               " vrs. ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", inference()$j )
    
       , tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               " estimate is ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", formatz3(inference()$res)) ,
   
     tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               " 95%CI ( ") 
      
      , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", formatz3(inference()$L)) ,
     
     
        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
     
    ",  ")
    
      , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", formatz3(inference()$H) ),
    
    
       tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
    
    " ) ") 
    
  ))
  
})

 

``` 


<!-- tab2 $\alpha$ -->
<!-- ==== -->

<!-- ```{r, not used} -->


<!-- ``` -->
 
Method Comparison Diagnostics
====

<!-- Column {.sidebar} -->
<!-- ----------------------------------------------------------------------- -->


```{r gammapoisson}

                                
    # sliderInput('N.pg', 'Patients per arm', value=1000,
    #               min = 1000, max = 100000, step=5, ticks=F)
    # 
    # sliderInput('mu0.pg', 'Placebo event rate \u03BC per patient yr of follow up', value=1,
    #               min = 0.1, max = 25, step=.05, ticks=F)
    # 
    # sliderInput('eff.pg', 'Hypothesised treatment effect ', value=.75,  # 1/2 ing to doubling
    #               min = 0.5, max = 2, step=.05, ticks=F)
    # 
    # sliderInput('k.pg', 'This needs to be \u03B1 the heterogeneity (ancillary) parameter. \u03B1 = 1/k', value = 1.3 ,  
    #               min = 0, max = 5 ,step=0.01, ticks=F)
    # 
    # sliderInput('d1.pg', 'Placebo discontinuation prob', value = c(0.1),
    #               min = 0, max = .5 ,step=0.05, ticks=F)
    # 
    # sliderInput('d2.pg', 'Treatment discontinuation prob', value = c(0.1),
    #               min = 0, max = .5 ,step=0.05, ticks=F)
    # 
    # sliderInput('fup.pg', 'Follow up (yrs)', value = c(1),
    #         min = 1, max = 10, step=1,ticks=F)

```

Method Comparison Diagnostics
 

Column {data-width=400, height=300}
-----------------------------------------------------------------------

### Constant SD assumption

```{r, gp barplots, eval=TRUE}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 
  r2 <- reactive({
 
    L1 <-     input$mu0
    L2 <-     input$mu0+input$eff.p
    r  <-     input$r
    n <-      input$n
    sd. <-    input$sd.
    

    A <- r1()$pp1
    B <- r1()$pp2
    n <- input$n
    
    d <- data.frame(y = A , x = B)
    
    my_data <- data.frame( 
      group = rep(c("before", "after"), each = n),
      counts = c(d[,1],  d[,2]),
      ID=rep(1:n,2)
    )
    
    m <- Meth(my_data,meth="group",item="ID",repl=NULL,y="counts",print=TRUE)
     
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # code from my useful code, adjusted slightly

  BA <- DA.reg(m, DA.slope = TRUE)

  a1<-as.data.frame(unlist(BA))
  #DA.slope.p<-a1[14,]
  #cons.sd.p.value<-a1[38,]
  
  res<-rbind(a1[14,], a1[38,])
  res<-as.matrix(res)
  
  rownames(res)<-c( 
                   "DA Slope P-value",
                   "P-value for Changing SD")
  
  colnames(res) <- c("Bland Altman Analysis")
 # print(res)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  ## **Assess Bland Altman assumptions P-values for two hypotheses:**
  w <- to.wide(m)
  ## assumptions do it yourself

  w$y <- w$before - w$after
  w$y <- w$after - w$before
  
  w$x <-  (w$before + w$after) /2
  
  # Constant difference - this is the test of 0 slope in the regression of differences on averages.
  f <- summary(lm(y~x, w))
  con.diff <- f$coefficients["x","Pr(>|t|)"]
  
  
  # Constant variance - this is the test of 0 slope in the regression of absolute residuals on averages.
  w$r <- abs(residuals(f) ) # if you dont use abs the regression line slope will be 0!
  # w$r <- (residuals(f) )
  # plot(r~x,w)
  f1 <- summary(lm(r~x, w))
  con.sd <- f1$coefficients["x","Pr(>|t|)"]
  
  return(list( con.diff=con.diff, con.sd=con.sd , w=w ))
  

})

renderPlot({
  
w <- r2()$w
con.sd <- r2()$con.sd
  
  ggplot(w, aes(x=x, y=r))+
    geom_point() +  
    geom_smooth(method="lm", col="black")  +
    stat_regline_equation(label.x = min(w$x), label.y = max(w$r))+
    theme_bw() +
    labs(title = paste0("First regressing the differences on the averages and then regressing the absolute residuals from this on the averages.\nTesting hypothesis slope=0, p=", formatz3(con.sd)),
         x = "Averages",
         y = "Absolute residuals")
   
})

 

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

``` 

### Constant difference assumption

```{r nb barplots, eval=TRUE}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

renderPlot({
  
w <- r2()$w
con.diff <- r2()$con.diff
 

  ggplot(w, aes(x=x, y=y))+
    geom_point() +  
    geom_smooth(method="lm", col="black")  +
    stat_regline_equation(label.x = min(w$x), label.y = max(w$r))+
    theme_bw() +
    labs(title = paste0("Regression of differences on averages.\nTesting hypothesis slope=0, p=", formatz3(con.diff)),
         x = "Averages",
         y = "After - before")

})
 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


```
   
Column {.tabset .tabset-fade}
-----------------------------------------------------------------------

### Constant difference assumption
  

```{r diagnostics1, eval=TRUE}

renderPlot({
  
  w <- r2()$w
  con.diff <- r2()$con.diff
  
  mod1 <- lm(y ~ x, data = w) 
  w$pred = predict(mod1)  
  
  p <- w %>%
    ggplot(aes(x = x, y = y) ) +
    geom_point(pch = 21, color = "white", fill = "black", size = 2, alpha = 0.8) +
    geom_smooth(method = "lm", colour = "black", se=TRUE, level=.95, fill="cornflowerblue") +
    stat_regline_equation(label.x = min(w$x), label.y = max(w$y))+
    
     labs(title = 
    paste0("Regression of differences on averages. Testing hypothesis slope=0, p=", formatz3(con.diff)),
         x = "Averages",
         y = "After - before") +

    geom_segment(
      aes(xend = x, yend = pred),
      size = 0.5, alpha = 0.8, lineend = "round", col="pink"
    ) +
    
    theme_bw(base_size = 12)
  
    ggMarginal(p, type = "histogram", bins = 50)

})

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

```

###  Constant variance assumption
 
```{r diagnostics2}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# x averages
# y differences
# r abs residuals

renderPlot({
  
w <- r2()$w

  con.sd <- r2()$con.sd
  
  f <- summary(lm(y~x, w)) # First regressing the differences on the averages 
  w$r <- abs(residuals(f) ) 
  mod1 <- lm(r ~ x , data = w) # regressing the absolute residuals from this on the averages
  
  w$pred = predict(mod1) # pred and fitted no dif with linear model
 # w$pred = fitted(mod1) 

p1 <-  ggplot(w, aes(x=x, y=r))+
    geom_point(pch = 21, color = "white", fill = "black", size = 2, alpha = 0.8) +
    geom_smooth(method = "lm", colour = "red", se=TRUE, level=.95, fill="#69b3a2") +
     stat_regline_equation(label.x = min(w$x), label.y = max(w$r))+
    theme_bw() +
    labs(title = paste0("First regressing the differences on the averages and then regressing the absolute residuals from this on the averages. Testing hypothesis slope=0, p=", formatz3(con.sd)),
         x = "Averages",
         y = "Absolute residuals") +
    
    geom_segment(
      aes(xend = x, yend = pred),   ## trying to join to reg line
      size = 0.5, alpha = 0.8, lineend = "round", col="pink"
    ) +
    
    theme_bw(base_size = 12)

  ggMarginal(p1, type = "histogram", bins = 50)

})
  

```

### histogram of differences
  

```{r diagnostics3, eval=TRUE}
 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# https://statisticsglobe.com/normal-density-curve-on-top-of-histogram-ggplot2-r
# calculate mean and sd by group
# stats <- aggregate(y~1, w, function(x) c(mean=mean(x), sd=sd(x)))
 

renderPlot({
  
w <- r2()$w

  df <- w
  
  argz1 <- c(   mean(df$y),   input$eff.p)
  argz2 <- c(   sd(df$y),     sqrt(r1()$true) )
  colz <-  c("black", "red")
  
  xv <- argz1[2]+1.2

 p <- ggplot(df, aes(y)) +      
  
  geom_histogram(aes(y = ..density..),
                 colour = "white", fill = "cornflowerblue", size = 0.1) +
 
   theme_bw() +
  
  annotate("text",  x=xv, y=.8, label= paste0("Estimated Mean differences = ", formatz3(mean(df$y))," and SD of differences = ",          formatz3(sd(df$y)), " (black)"))  +
  annotate("text",  x=xv, y=.7, label= paste0("True Mean difference = ",      formatz3( input$eff.p),", and true SD of differences = " ,  formatz3(sqrt(r1()$true)) ,  " (red)"))
  
# https://stackoverflow.com/questions/2237600/how-can-i-plot-multiple-functions-in-r
 # adding density plots
 for(i in 1:2)
   
    p <- p +  stat_function(fun = dnorm,
                args = list( mean = argz1[i], sd = argz2[i] ),
                col = colz[i],
                size = 1.5)
    print(p)

})

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 
```

### not used yet 
 
 
```{r diagnostics4}

  
```

### not used yet
 
 
```{r diagnostics5}

   

```

### not used yet

```{r diagnostics6, eval=TRUE}

  
```

Method Comparison with replicates!      
===

Column {.sidebar data-width=380}
-----------------------------------------------------------------------

**Design your method comparison, replication! **

```{r mc2}
 
#   
# textInput('methodz', 
#           strong(div(h5(tags$span(style="color:blue", 
#             "No of methods, No of sample")))), "2, 20")
#  textInput('samplez', 
#            strong(div(h5(tags$span(style="color:blue", 
#              "No of items")))), "20")
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# orange button

  actionButton("resample_2",   "Hit to simulate a new sample", style = "width:100%;")

 
       
   tags$style(HTML('#resample_2{background-color:orange}'))
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
output$text.reg.notes2 <- renderText({  # create text

    print(paste0(   

        tags$span(style="color:blue;font-size: 15px;", 
          
     "In the methods box the first entry is the no. of methods (try changing the 3 to 2!). The following are those that are presented in the BA plot top left.")) )

 })

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  h5(htmlOutput("text.reg.notes2"))    
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 splitLayout(
       textInput('methodz', 
          strong(div(h5(tags$span(style="color:blue", 
            "No of methods")))), "3,1,2"),
       
 textInput('samplez', 
           strong(div(h5(tags$span(style="color:blue", 
             "No of samples")))), "20"),
 
textInput('repz', 
          strong(div(h5(tags$span(style="color:blue", 
           "Reps")))), "2,1")
                           )

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
output$text.reg.notes <- renderText({  # create text
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    print(paste0(   

        tags$span(style="color:blue;font-size: 15px;", 
          
     "Vectors of method-specific intercepts and slopes for the linear equation relating the 'true' underlying sample mean measurement to the mean measurement on each method")) )

 })

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  h5(htmlOutput("text.reg.notes"))    

 splitLayout(
    textInput('alphaz', 
              strong(div(h5(tags$span(style="color:blue", 
            "alphas")))), "0,0.4,0"),
    
    textInput('betaz', 
              strong(div(h5(tags$span(style="color:blue", 
              "betas")))), "1,1,1")
)
 
 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  textInput('sigma.irz', 
            strong(div(h5(tags$span(style="color:blue", 
              "'IxR' Method-specific standard deviations for the sample by replicate random effect.")))), "0.02,0.03, 0.05")

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
  textInput('sigma.miz', 
            strong(div(h5(tags$span(style="color:blue", 
              "'MxI' Method-specific standard deviations for a method by sample random effect. Some or all components can be zero.")))), "0.062,0.062, 0.05")


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  textInput('sigma.mirz', 
            strong(div(h5(tags$span(style="color:blue", 
              "'res' A vector of method-specific residual standard deviations for a method by sample by replicate random effect (residual variation). All components must be greater than zero.")))), "0.128,0.143, 0.222")
 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  textInput('mu.rangez', 
            strong(div(h5(tags$span(style="color:blue", 
              "The range across items of the 'true' mean measurement. Sample means are uniformly spaced across the range. ")))), "-0.5 ,1")
 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  textInput('mizz', 
            strong(div(h5(tags$span(style="color:blue", 
             "Fraction of the observations from each method to keep, fraction of the observations from each sample to keep")))), "1 ,1")
 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  selectInput("Pl.typez", 
              strong(div(h5(tags$span(style="color:blue",
              "Select plot type (main top left)")))),  choices = c("BA", "conv"), selected="BA")
    
  selectInput("modelz", 
                strong(div(h5(tags$span(style="color:blue",
              "Model: replicates exchangable or linked?")))),  
              choices = c("exch", "linked"), selected="exch")
  
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  

 

```

The top two drop down menus allow different modelling approaches. Note, the default settings reflect the true data generating mechanism.

Column {data-width=400}
-------------------------------------

### Bland Altman or conversion plot, comparison and plot can be selected by user (lines joining dots only applicable for linked replicates)

```{r, mc2 B}

   # --------------------------------------------------------------------------
 

renderPlot({
  
  foo <- r1_2()$foo  # bring in data
   
  xx <- random.sample_2()  # bring in methods to plot
  
f<- Meth( data=foo  ,meth="meth",
          item="item", repl="repl", y="y",  
          keep.vars=!is.null(data) , print=F) 

par(mar=c(5.1,4.1,4.1,4))

BA.plot(f, 
      
        
        wh.comp=c(xx$mz[2], xx$mz[3]), 
      
        model=input$modelz,
      
        repl.conn=TRUE, 
      col.lines="gray60", 
      col.conn = "brown",
        col.eqn = "black" ,
        font.eqn = 3,
       # axlim=c(-1.5,.75), 
      
       # diflim=c(-20,20), 
      xaxs="i", yaxs="i",
      col.points='blue',
        #cex.points = 0.5,
        las=1, eqn=TRUE, eqax=TRUE, 
        # dif.type="cons",
        # sd.type="cons",
      
 #       dif.type=input$Dif.typez,
  #      sd.type=input$SD.typez,
        pl.type=input$Pl.typez, 
      
        #grid=seq(-1.6,.8,.1), 
        grid=TRUE,
        digits=3,Transform=F, 
        
        col.grid=gray(0.9))

if ( input$Pl.typez=="conv") abline(a=0, b=1,   lty=2, col = "purple", lwd=2)


})
  # --------------------------------------------------------------------------


```

### Plots showing relationships between all methods

```{r, mc2 C}

    
  # --------------------------------------------------------------------------


renderPlot({
  
    foo <- r1_2()$foo
   
    plot(foo)
    
})

  # --------------------------------------------------------------------------
 

```

Column {.tabset .tabset-fade}
-----------------------------------------------------------------------

### Introduction

```{r mc2 D}
 
   # --------------------------------------------------------------------------
    # I looked back to two period cross over trial to get this button working to resimulate
    # This is where a new sample is instigated only random noise is required to be generated

 random.sample_2 <- reactive({
      
    # Dummy line to trigger off button-press
    foo <- input$resample_2
    
   nz <-     as.numeric(unlist(strsplit(input$samplez,   ",")))
   mz <-     as.numeric(unlist(strsplit(input$methodz,   ",")))
   az <-     as.numeric(unlist(strsplit(input$alphaz,    ",")))
   bz <-     as.numeric(unlist(strsplit(input$betaz,     ",")))
   rz <-     as.numeric(unlist(strsplit(input$repz,      ",")))
   miz <-    as.numeric(unlist(strsplit(input$sigma.miz, ",")))
   irz <-    as.numeric(unlist(strsplit(input$sigma.irz, ",")))
   mirz <-   as.numeric(unlist(strsplit(input$sigma.mirz,",")))
   rangez <- as.numeric(unlist(strsplit(input$mu.rangez,",")))
   mizz <-   as.numeric(unlist(strsplit(input$mizz,      ",")))

    
   foo <- Meth.sim(Ni=nz[1] , 
                   Nm=mz[1],
                
                Nr=rz[1], 
                nr=rz[2],
                alpha=az, 
                beta= bz,
                
                m.thin=mizz[1], 
                i.thin=mizz[2],
                
                sigma.mi=miz, 
                sigma.ir=irz, 
                sigma.mir=mirz , 
                
                mu.range=rangez
                )
        
    return(list(foo=foo, miz=miz, irz=irz, mirz=mirz, mz=mz))
     })
   
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


  r1_2 <- reactive({
 
   sample <- random.sample_2()
    
   nz <-     as.numeric(unlist(strsplit(input$samplez,   ",")))
   mz <-     as.numeric(unlist(strsplit(input$methodz,   ",")))
   az <-     as.numeric(unlist(strsplit(input$alphaz,    ",")))
   bz <-     as.numeric(unlist(strsplit(input$betaz,     ",")))
   rz <-     as.numeric(unlist(strsplit(input$repz,      ",")))
   
   miz <-    sample$miz  # the sds
   irz <-    sample$irz
   mirz <-   sample$mirz
   
   rangez <- as.numeric(unlist(strsplit(input$mu.rangez, ",")))
   mizz <-   as.numeric(unlist(strsplit(input$mizz,      ",")))
    
    # repeat the data generation the sds will produce fresh data
   foo <-  Meth.sim(Ni=nz[1] , 
                   Nm=mz[1],
                Nr=rz[1], 
                nr=rz[2],
                alpha=az, 
                beta= bz,
                m.thin=mizz[1], 
                i.thin=mizz[2],
                
                sigma.mi=miz, 
                sigma.ir=irz, 
                sigma.mir=mirz , 
                
                mu.range=rangez
                )
     

 return(list( foo=foo ))
     
  })
  
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 # h5(htmlOutput("text3z"))      ## print 
  
```

### Data Listing

```{r mcomp2.1}

# not used yet

    Listing <- reactive({
  
      foo <- r1_2()$foo
      
           w <- to.wide(foo)
        
          #separate by replicate and merge together
          r1<-w[w$repl==1,]
          r2<-w[w$repl==2,]
          
          w2<-merge(r1,r2, by.x="item", by.y="item")
        
    return(list(w=w ))
          
     })



  renderPrint({
  
    w <- Listing()$w
    rownames(w) <- NULL  # refressh rownames
    print(w)
  
  })
        
     
```

### Analysis, exchangable replicates
 

```{r mcomp2.2}

# not used yet
 
lmm <-  reactive({
  
    foo <- r1_2()$foo

    f <- BA.est( foo, linked=FALSE, IxR =TRUE, MxI = TRUE )
    
   return(list(f=f, foo=foo))
       
   })


  renderPrint({
  
    m1 <-  lmm()$f
     foo <- r1_2()$foo
    
   cat("\nTo calculate the sd.pred for 2 methods sum each method's component's (MxI^2, res^2) and take the square root. The item×replicate (IxR)
standard deviation is not related to the method comparison, but only to the study design it is not an effect of any predictive relevance.\n")
    print(m1)
    cat("\nCheck within a method, residual * sqrt(2) gives the standard deviation of the differences below,  multiply this by 2 to give 95% Limit of Agreement\n")
    print(m1$RepCoef)
    cat("\nLet's run the lme model:\n")
    
     mz <-     as.numeric(unlist(strsplit(input$methodz,   ",")))

        # Bendix book page 144 re pdIdent v pdIdiag
    if (mz[1] < 3) {
    print(lme( y ~ meth + item,
          random=list( item = pdIdent( ~ meth-1 )  ),
          weights = varIdent( form = ~1 | meth ),
          data = foo ))
      
  } else {
      print(lme( y ~ meth + item,
          random=list( item = pdDiag( ~ meth-1 )  ),
          weights = varIdent( form = ~1 | meth ),
          data = foo ))
  }
  })
  
 
```

### Analysis, linked replicates
  

```{r mcomp2.3}

 
  lmm1 <-  reactive({
  
    foo <- r1_2()$foo

    fL <- BA.est( foo, linked=TRUE, IxR =TRUE, MxI = TRUE  )

    return(list( fL=fL))
           
     })


  renderPrint({
  
     m2 <- lmm1()$fL
      foo <- r1_2()$foo
     cat("\nTo calculate the sd.pred for 2 methods sum each method's component's (MxI^2, res^2) and take the square root. The item×replicate (IxR)
standard deviation is not related to the method comparison, but only to the study design it is not an effect of any predictive relevance.\n")
     print(m2)
     cat("\nCheck within a method, residual * sqrt(2) gives the standard deviation of the differences below,  multiply this by 2 to give 95% Limit of Agreement\n")
     print(m2$RepCoef)
     cat("\nLet's run the lme model:\n")
    
     mz <-     as.numeric(unlist(strsplit(input$methodz,   ",")))

        # Bendix book page 144 re pdIdent v pdIdiag
    if (mz[1] < 3) {
    print(lme( y ~ meth + item,
          random=list( item = pdIdent( ~ meth-1 ), repl = ~ 1 ),
          weights = varIdent( form = ~1 | meth ),
          data = foo ))
      
  } else {
      print(lme( y ~ meth + item,
          random=list( item = pdDiag( ~ meth-1 )  , repl = ~ 1 ),
          weights = varIdent( form = ~1 | meth ),
          data = foo ))
  }
     
  
   })

 
 # IXR

```

### Boxplots, dots indicate reps, items by coloured lines
 
 
```{r mcomp2.4}

 renderPlot({
 
    d <- r1_2()$foo
    
    xx <- random.sample_2()       # bring in methods to plot
    wh.comp=c(xx$mz[2], xx$mz[3]) # bring in 2 methods
 
    d$meth <- as.numeric(as.character(d$meth)) # make numeric to add some jitter
    
    d <- d[d$meth %in% wh.comp,]   # subset so there are two methods using usede inputs

    d$xj <- jitter( d$meth, amount=.13)  # jitter
    
    d$grp <- paste(d$item, d$repl, sep=".") # this is need for plot

    # code based on count app
    AA <- ggplot(data=d, aes(y=y) ) +
      geom_boxplot(aes(x=meth, group=meth), width=0.2, outlier.shape = NA, col='blue', fill='lightblue') +
      geom_line(aes(x=xj, group=grp),  colour=d$grp, alpha=.5) +
      geom_point(aes(x=xj), size=2,  colour=d$repl) +
      xlab("Method") + ylab("y") +  
      scale_x_continuous(breaks=wh.comp ) +
      theme_bw() + theme(legend.position = "none") 
  
    print(AA)
    
})



  
```

### Permute the replicates
 
 
```{r mcomp2.5}

 renderPlot({
     plot(perm.repl(r1_2()$foo))
  })

```

### Analyse as if there were no replication?

```{r mcomp2.6}

 



renderPlot({
  
  
     d <- r1_2()$foo
     w <- to.wide(d)
     
    xx <- random.sample_2()       # bring in methods to plot
    wh.comp=c(xx$mz[2], xx$mz[3]) # bring in 2 methods
 
     
     
    
    
     library(dplyr)
     A <-  w %>% pull(as.character(wh.comp[1]))
     B <-  w %>% pull(as.character(wh.comp[2]))
     
     n <- dim(w)[1]
    
    d <- data.frame(y = A , x = B)
  
    my_data <- data.frame( 
      group = rep(c(wh.comp[1], wh.comp[2]), each = n),
      counts = c(d[,1],  d[,2]),
      ID=rep(1:n,2)
    )
  
   m <- Meth(my_data,meth="group",item="ID",repl=NULL,y="counts",print=TRUE)
   
   L <- max(abs(floor(min(A-B))),abs(ceiling(max(A-B))))
   
   L <- roundUp(L)
    
    # we set up const dif and const sd so that will matches true data generating mechanism
    par( mfrow=c(1,1), mar=c(3,3,1,3), mgp=c(3,1,0)/1.6 )
   
    BA.plot( m, model=NULL, repl.conn=TRUE,  
             
              col.lines="gray60", 
   
        col.eqn = "black" ,
        font.eqn = 3,
             
             # axlim=c(0,20), 
            # diflim=c(-L,L), 
             xaxs="i", yaxs="i",
              col.points='blue',
             las=1, eqn=TRUE,   
             pl.type=input$Pl.typez, 
             sd.type=input$SD.type, 
             dif.type = input$Dif.type, # cons is simulatied
             grid=1:9*10, digits=3,
        #font.eqn=1  , 
        eqax=T, col.grid=gray(0.9))
    
if ( input$Pl.typez=="conv") abline(a=0, b=1,   lty=2, col = "purple", lwd=2)

})



 










```


 
```{r texts} 

  # --------------------------------------------------------------------------
output$text2z <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "If the variables are uncorrelated the variance of the difference is equal to the sum of the variances. If there is any correlation this information is incorporated: ")))
  
})
  # --------------------------------------------------------------------------

output$text2az <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "The following is the covariance between the two variables. Add 2 x this if we are interested in the variance of the sum, for the variance of the difference subtract 2 x this component. ")))
  
})
   # --------------------------------------------------------------------------
   

output$text3z <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "A method comparison with ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", input$n_2) ,
   
     tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               " samples assayed on each of two methods. There is a true difference (after - before) of ") 
      
      , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", input$eff.p_2) ,
     
     
        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
     
    ", also there is a true correlation between the paired results of ")
    
      , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", input$r_2) ,
    
    
        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
    
    " and between sample SD commmon to both methods of ")
    
      , tags$span(style="color:blue ;font-weight:bold;font-size: 20px;", input$sd._2) ,
    
     tags$span(style="color:black;font-weight:bold;font-size: 20px;",
               
    ". By design the SD is constant across the range of values. Think of this SD component as the between person SD. Increase it to see the range of scores increase. We are not particularly interested in the between sample SD, this depends on the samples we choose and it is advisable to select samples that span range of the devices if possible. There are no technical replicates ", #),
    
    
        ".") ))
  # --------------------------------------------------------------------------
 })
 

output$text4z <- renderText({  # create interactive text t1

    print(paste0(   

        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "Based on the true parameters, the variance of the difference, calculated using the above equation, is ") 
    
         , tags$span(style="color:blue ;font-weight:bold;font-size: 20px;",formatz1( r1_2()$true )),
                     
                     tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
    
     ", this equates to an SD of the differences of ") 
    
       , tags$span(style="color:blue ;font-weight:bold;font-size: 20px;", formatz3(sqrt(r1_2()$true))) ,
    
     tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               ". The estimate from a simulated experiment is ") 
    
     , tags$span(style="color:blue ;font-weight:bold;font-size: 20px;", formatz3( r1_2()$est )),
                 
                  tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
    
        ", this equates to an SD of the differences of ")
    
     , tags$span(style="color:blue ;font-weight:bold;font-size: 20px;", formatz3( sqrt(r1_2()$est)),
    
                 ##add some more text
                  tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
    
        ", this matches the methComp estimate with the default settings, see the estimate in brackets in the Bland Altman plot top right"),".") ))

 })


output$text4az <- renderText({  # create interactive text t1

    print(paste0(   

        tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
          
     "Notice there are no technical replicates per sample on each method. The repeatability of each method therefore cannot be estimated, this is a deficiency in the experimental design.")) )

 })
  # --------------------------------------------------------------------------
 

``` 
 

T-test 
====

Column {.sidebar}
-----------------------------------------------------------------------

Here we define the parameters of a lognormal distribution and a proportional change (independent groups)

```{r, main power tab2}
 
    
      div(h5(tags$span(style="color:blue", "Enter true population values:")))

      textInput("v3", div(h5(tags$span(style="color:blue", "Sample size per arm"))),     value= "60")
      textInput("v1", div(h5(tags$span(style="color:blue", "Log Normal mean"))),     value= "100")
      textInput("v2", div(h5(tags$span(style="color:blue", "Log Normal SD"))),      value= "50")
      textInput("v4", div(h5(tags$span(style="color:blue", "Confidence Level"))),    value= "0.90")
      textInput("v5", div(h5(tags$span(style="color:blue", "QC Level"))),            value= "0.85")
      textInput("v6", div(h5(tags$span(style="color:blue", "Proportional change"))), value= "0.95")
      
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   # orange button
   actionButton("resampley",   "Hit to simulate a new sample")
      
   #  tags$head(
   tags$style(HTML('#resampley{background-color:orange}'))
   # )
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
       
# try these means and sds
# 0.3  0.08
# 0.19 0.15 
# 0.42 0.32
# 0.96 0.1
# 0.9  0.09
       
      
 output$text55 <- renderText({  # create interactive text t1

    print(paste0(   
    
       tags$span(style="color:black;font-weight:bold;font-size: 20px;",  "To meet the QC level of ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", random.sample2()$qc )
    
     , tags$span(style="color:black;font-weight:bold;font-size: 20px;",  " means the entire ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;",  random.sample2()$conf*100 )
     
     , tags$span(style="color:black;font-weight:bold;font-size: 20px;", " % confidence interval of the contrast must lie within ") 
     
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;",  random.sample2()$qc*100 )
                 
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;",   "/100" )
     
     , tags$span(style="color:black;font-weight:bold;font-size: 20px;",   " = " )
                 
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;",  random.sample2()$qc )  
                  
     , tags$span(style="color:black;font-weight:bold;font-size: 20px;",   " and " )
     
      , tags$span(style="color:blue;font-weight:bold;font-size: 20px;",   "100/" ) 
     
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;",  random.sample2()$qc*100 )  
                    
     , tags$span(style="color:black;font-weight:bold;font-size: 20px;",   " = " )
                  
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;",  formatz2(100/(random.sample2()$qc *100) )) 
   
  ))
   
})
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    h5(htmlOutput("text55"))   

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

```


```{r text power, eval=TRUE}

    random.sampley <- reactive({
      
     # Dummy line to trigger off button-press
     foo <- input$resampley
         
     a    <- as.numeric(eval(parse(text= (input$v2)) ) )  # the random component , only need this for button  
  
     return(list(a=a))
     
     })

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  random.sample2 <- reactive({

    sampley <- random.sampley()
    
    # writing like this I can write log and fraction into input boxes!
    mux  <- as.numeric(    eval(parse(text= (input$v1)) ) )
    #a    <- as.numeric(    eval(parse(text= (input$v2)) ) )  # sd 
    n    <- as.numeric(    eval(parse(text= (input$v3)) ) )
    conf <- as.numeric(    eval(parse(text= (input$v4)) ) )
    qc   <- as.numeric(    eval(parse(text= (input$v5)) ) )
    zx   <- as.numeric(    eval(parse(text= (input$v6)) ) )
    #normal_to_lognormal(normmean = mux, normsd = a)
    
    a <-    sampley$a # change with push of button
    
    v <- a^2
    m <- mux
    
    phi = sqrt(v + m^2);
    mu    = log(m^2/phi)          # mean of log(Y)     
    sigma = sqrt(log(phi^2/m^2))   # std dev of log(Y)  
      
    # feed normal distirbution parameters into this function:
    zz <- power.t.test(n=n, delta =log(zx), sd=sigma, sig.level=0.05,
                      # power=pow,
                       type="two.sample", alternative=c("two.sided"))
    
     
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # this duplicates my code
    #lognormal_to_normal(meanlog=mu, sdlog=sigma)
    
    v <- sigma^2
    logN.mu <- exp(mu+0.5* v)
    logN.SD <- logN.mu*sqrt(exp(v)-1)
    
    #------------------------------------------------------------------------------
    
    N <- ceiling(zz$n)
    sd    <- sigma
    delta <- log(zx)
    
    A <- lapply(1:N, function(i) rlnorm(1, meanlog=mu,       sdlog=sd))
    B <- lapply(1:N, function(i) rlnorm(1, meanlog=mu+delta, sdlog=sd))
    
    A <- unlist(A)
    B <- unlist(B)
    
    A.GM <- exp(mean(log(A)))
    B.GM <- exp(mean(log(B)))
    
    #------------------------------------------------------------------------------
        return(list(
          
         mu=mu, sd=sd, zz=zz, logN.mu=logN.mu, logN.SD=logN.SD, 
         delta=delta, A.GM=A.GM, B.GM=B.GM, zx=zx, A=A, B=B, N=N, conf=conf, qc=qc,  mux=mux
    
        ))
      })

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

```
 
Column {data-width=400, height=75}
-----------------------------------------------------------------------
 
   
### The top left panel are histograms on the original scale, the right, natural log transformed versions

```{r power typical barplot}

renderPlot({

  N <-        random.sample2()$N
  mu <-       random.sample2()$mu
  mux <-      random.sample2()$mux
  logN.mu <-  random.sample2()$logN.mu
  logN.SD<-   random.sample2()$logN.SD
  zx<-        random.sample2()$zx
  sd<-        random.sample2()$sd
 
  A<-         random.sample2()$A
  B<-         random.sample2()$B#
  A.GM<-      random.sample2()$A.GM
  B.GM<-      random.sample2()$B.GM
 
  delta <-   random.sample2()$delta
 
    # common limits for plotting
    lx <- floor(min(A, B))
    ux <- ceiling(max(A,B))
    
    llx <- floor(  min(log(A), log(B)))
    lux <- ceiling(max(log(A), log(B)))
  
  
    par(mfrow=c(2,2))
    
    x<-seq(-8+mu,+8+mu,by=0.02) # range of values to plot over
    
    br <- ifelse(N<100, N, 100) # bins in histograms
    
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    MASS::truehist(A, 
                  yaxt='n' ,
                  nbins=br,  axes=FALSE,  xlim=c(lx,ux),
    main=paste0("A. N=",N," realisations from log-normal mu=", formatz00(logN.mu),", SD=", formatz00(logN.SD),
                ", Sample Geometric Mean=",p3(A.GM)), col = "blue", 
                  border = "white", xlab="Original scale")
    #adding log normal curve, here the mean and sd of the transformed dist are entered
    curve(dlnorm(x, meanlog = mu, sdlog =sd, log = FALSE), add=TRUE)   
    Axis(side=1, labels=TRUE)
    Axis(side=2, labels=FALSE)
    
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    MASS::truehist(log(A),
                   yaxt='n' , 
                   nbins=br,  axes=FALSE,  xlim=c(llx,lux),
    main=paste0("A. N=",N," log transformed of left data, theoretical mu=", p3(mu),", SD=", p3(sd),
                ""), col = "blue", border = "white",  xlab="log scale")
    #adding normal curve, here the mean and sd of the transformed dist are entered, as above, just dist differs
    curve(dnorm(x,mu,sd), add=TRUE)           
    Axis(side=1, labels=TRUE)
    Axis(side=2, labels=FALSE)
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    MASS::truehist(B, 
                    yaxt='n' ,
                    nbins=br,  axes=FALSE, xlim=c(lx,ux),
    main=paste0("B. N=",N," realisations true log-normal mu=",formatz00(mux*zx),", SD=", formatz00(logN.SD), 
                ", sample Geometric Mean=",p3(B.GM) ,"\nTrue treatment effect ",mux*zx," / ",mux,"=",zx), 
                   col = "orange", border = "white", xlab="Original scale")
     
    curve(dlnorm(x, meanlog = mu+delta, sdlog =sd, log = FALSE), add=TRUE)  
    Axis(side=1, labels=TRUE)
    Axis(side=2, labels=FALSE)
    
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    MASS::truehist(log(B), 
                   yaxt='n' ,
                   nbins=br, axes=FALSE, xlim=c(llx,lux),
      main=paste0("B. N=",N," log transformed of left data, theoretical mu=", p3(mu+delta),", SD=",p3(sd), 
                  "\nTrue treatment effect ", p3(mu+delta)," - ",p3(mu),"=",
                               p3(log(zx))), col = "orange", border = "white", xlab="log scale" )
    
    curve(dnorm(x,mu+delta,sd), add=TRUE)
    Axis(side=1, labels=TRUE)
    Axis(side=2, labels=FALSE)
    
    par(mfrow=c(1,1))
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


})

 
```

Column {data-width=400}
-------------------------------------

### Boxplots on the original scale plus inferential calculations
  
```{r}  
  
  renderPlot({
  
    
  N <-  random.sample2()$N
  mu <-  random.sample2()$mu
  mux <-  random.sample2()$mux
  logN.mu <-  random.sample2()$logN.mu
  logN.SD<-  random.sample2()$logN.SD
  zx<-  random.sample2()$zx
  sd<-  random.sample2()$sd
 
  A<-  random.sample2()$A
  B<-  random.sample2()$B#
  A.GM<-  random.sample2()$A.GM
  B.GM<-  random.sample2()$B.GM
 
 
  delta <-  random.sample2()$delta
 
  conf    <- random.sample2()$conf
  qclevel <- random.sample2()$qc

  d <- data.frame(x =c(rep( "A" , N), rep( "B" , N)), y=c(A,B))
  
  res <- t.test(log(d$y)~d$x, var.equal = TRUE, conf.level=conf) # t test
  
  ci <- exp(-res$conf.int)
  hi <- round(ci[1],3)
  lo <- round(ci[2],3)
  
  qc <- ifelse(((qclevel<=lo) && (hi<=1/qclevel)), paste0("PASS spec. of ", qclevel), paste0("FAIL spec. of ", qclevel))
  GmeanR <- round(exp(res$estimate[1]),3) # geometric means
  GmeanT <- round(exp(res$estimate[2]),3) # geometric means
  
  # %CV get the sd of the logged data and exponenitate
  cv1 <-exp(tapply(log(d$y), d$x, sd))
  GmeanRcv <-  round((((cv1[1])-1)*100),3)
  GmeanTcv <-  round((((cv1[2])-1)*100),3)
  
  ratio. <- exp( (res$estimate)[2] - (res$estimate)[1])
  ratio. <- round(ratio.,3)
  
 # run a ggplot 
  d$Y <-  (d$y)  # choose response

gx <- ggplot(d, aes(x=x, y=Y)) +
  
  geom_point(aes(fill=x), size=3, shape=21, colour="grey20",
             position =position_jitter(width=.22, height=0))+
  
  geom_boxplot(outlier.colour=NA, fill=NA,colour="grey20") +
  
  
  scale_fill_manual(values = c(A = 'blue', 
                               B = 'orange')) + 
  scale_colour_manual(values = c(A = 'blue', 
                               B = 'orange'))+
  
  labs(title=paste0("QC=", qc)) + xlab("") + ylab("score") +
  labs(subtitle = 
         paste0("Geometric mean A=" ,GmeanR,"; %CV=",GmeanRcv,
                "\nGeometric mean B=" ,GmeanT,"; %CV=",GmeanTcv,
                "\nRatio B/A " ,ratio.,", ",conf*100,"%CI (",lo,", ",hi,")")) +
  
  annotate("text", x=0.5, y=max(d$y), label=paste0("n=", table(d$x)[1][[1]])) +
  annotate("text", x=1.5, y=max(d$y), label=paste0("n=", table(d$x)[2][[1]]))    +
  theme(legend.position="none") +
  guides(fill="none") +
  theme_bw() 
 
  print(gx)

  })
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 
```
  
### Boxplots of log transformed data, labelled with antilogs plus inferential calculations

```{r BApylot}

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  renderPlot({
  
    
  N <-  random.sample2()$N
  mu <-  random.sample2()$mu
  mux <-  random.sample2()$mux
  logN.mu <-  random.sample2()$logN.mu
  logN.SD<-  random.sample2()$logN.SD
  zx<-  random.sample2()$zx
  sd<-  random.sample2()$sd
 
  A<-  random.sample2()$A
  B<-  random.sample2()$B#
  A.GM<-  random.sample2()$A.GM
  B.GM<-  random.sample2()$B.GM
 
 
  delta <-  random.sample2()$delta
 
  conf    <- random.sample2()$conf
  qclevel <- random.sample2()$qc
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
##### log the response and use exponentiated ticks
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
  d <- data.frame(x =c(rep( "A" , N), rep( "B" , N)), y=c(A,B))
  res <- t.test(log(d$y)~d$x, var.equal = TRUE, conf.level=conf) # t test

  ci <- exp(-res$conf.int)
  hi <- round(ci[1],3)
  lo <- round(ci[2],3)
  qc <- ifelse(((qclevel<=lo) && (hi<=1/qclevel)), paste0("PASS spec. of ", qclevel), paste0("FAIL spec. of ", qclevel))
  GmeanR <- round(exp(res$estimate[1]),3) # geometric means
  GmeanT <- round(exp(res$estimate[2]),3) # geometric means

  # %CV get the sd of the logged data and exponenitate
  cv1 <-exp(tapply(log(d$y), d$x, sd))
  GmeanRcv <-  round((((cv1[1])-1)*100),3)
  GmeanTcv <-  round((((cv1[2])-1)*100),3)

  ratio. <- exp( (res$estimate)[2] - (res$estimate)[1])
  ratio. <- round(ratio.,3)
 
   # now use the tick info on ggplot of log response
   d$Y <-  log(d$y)  # choose response
 
   # choose appropriate scale next scale bigger than max d$y
   scalez <- c(0.001, 0.01, .1 ,1, 10, 100, 1000, 10000, 1e5 , 1e6)
   top <-    min(which( max(d$y) < scalez))
   bottom <- max(which( min(d$y) > scalez))
   scalez <- scalez[bottom:top]
   
   ticks= log(scalez)
 
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   
   labs <- exp(ticks)  # exponentiate the labels
   
   g1 <- ggplot(d, aes(x=x, y=Y)) +
     geom_point(aes(fill=x), size=3, shape=21, colour="grey20",
                position =position_jitter(width=.22, height=0))+
     geom_boxplot(outlier.colour=NA, fill=NA,colour="grey20") +
  
       scale_fill_manual(values = c(A = 'blue', 
                               B = 'orange')) + 
  scale_colour_manual(values = c(A = 'blue', 
                               B = 'orange'))+
  
    scale_y_continuous(
      
     limits=c(   ticks[1],  ticks[length(ticks)]  ), 
        breaks= ticks,    # this is where the values go
        labels= labs) +   # these are labels
     
     labs(title=paste0("QC=", qc)) + xlab("") + ylab("score") +
     labs(subtitle = 
            paste0("Geometric mean A=" ,GmeanR,"; %CV=",GmeanRcv,
                   "\nGeometric mean B=" ,GmeanT,"; %CV=",GmeanTcv,
                   "\nRatio B/A " ,ratio.,", ",conf*100,"%CI (",lo,", ",hi,")")) +
     
     annotate("text", x=0.5, y=max(ticks), label=paste0("n=", table(d$x)[1][[1]])) +
     annotate("text", x=1.5, y=max(ticks), label=paste0("n=", table(d$x)[2][[1]]))    +
     theme(legend.position="none") +
     guides(fill="none") +
     theme_bw() 
   
   print(g1)
   
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   
    
  })
  
``` 


Anova (linear model) contrasts
====
 

Column {data-width=400}
-------------------------------------
  
### Plot on original scale
  
```{r left1, eval=TRUE}  


renderPlot({
  
   df <-  random.sample3()$dd
   
  yy <- ggplot(df, aes(reorder(IV,DV),DV,fill=IV))+

    stat_boxplot(geom ='errorbar',width = 0.4) +
    geom_boxplot(outlier.shape = NA) + #avoid duplication of outliers
    labs(title="Boxplot, dotplot and Standard error of mean for groups", 
         x = "Groups (sorted)",
         y = "Response",
         subtitle ="Blue dots=sample data points, Yellow dot=mean, Red=1 x standard error ",
         caption = "") +
    guides(fill="none") +
    
    geom_jitter(shape=21, fill="blue", color="darkred", size=3, width= 0.1) +
     
    stat_summary(fun.data = mean_se, geom = "errorbar", colour = "red", size = 1, width= 0.1)+
    stat_summary(geom="point", fun=base::mean, color="yellow",  size = 2) +
    theme_bw() 
    print(yy)
  
})


```
Column {data-width=400, height=75}
-----------------------------------------------------------------------
  
### Plots of natural log data with anti-log y-axis labels

```{r right2}

renderPlot({
  
   d <-  random.sample3()$dd
   
   df <-  random.sample3()$dd

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  scalez <- c(0.001, 0.01, .1 ,1, 10, 100, 1000, 10000, 1e5 , 1e6)
  top <-    min(which( max(d$DV) < scalez))
  bottom <- max(which( min(d$DV) > scalez))
  scalez <- scalez[bottom:top]
  ticks= log(scalez)
  labs <- exp(ticks)  # exponentiate the labels
  
  df$DV <- log(df$DV)
  
xx<-  ggplot(df, aes(reorder(IV,DV),DV,fill=IV))+
    
    stat_boxplot(geom ='errorbar',width = 0.4) +
    geom_boxplot(outlier.shape = NA) + #avoid duplication of outliers
    labs(title="Boxplot, dotplot and Standard error of mean for groups", 
         x = "Groups (sorted)",
         y = "Response",
         subtitle ="Blue dots=sample data points, Yellow dot=mean, Red=1 x standard error ",
         caption = "") +
    guides(fill="none") +
    
    scale_y_continuous(
      
      limits=c(   ticks[1],  ticks[length(ticks)]  ), 
      breaks= ticks,    # this is where the values go
      labels= labs) +   # these are labels
    
    geom_jitter(shape=21, fill="blue", color="darkred", size=3, width= 0.1) +
    
    stat_summary(fun.data = mean_se, geom = "errorbar", colour = "red", size = 1, width= 0.1)+
    stat_summary(geom="point", fun=base::mean, color="yellow",  size = 2) +
    theme_bw() 
 
print(xx)

})

```

Column {.sidebar}
-----------------------------------------------------------------------
  
**User inputs for 4 independent groups**

 
```{r}

      sliderInput("range1", 
                   "Select group sizes: randomly select using range or uniquely select:", 
                    min = 2, max = 5000, value = c(1000, 1000), ticks=FALSE) 
                            
      sliderInput("range2", 
                  "Select lognormal baseline group mean",  
                  min = 0.5, max = 40000, value = c(400),ticks=FALSE)
                            
      sliderInput("range3", 
    "Select true group standard deviations: randomly select using range or uniquely select", 
                  min = 20, max = 10000, value = c(1000, 1000), ticks=FALSE) 
      
      textInput("pr1", div(h5(tags$span(style="color:blue", "Prop Chg Grp B v Grp A"))), value= "2")
      textInput("pr2", div(h5(tags$span(style="color:blue", "Prop Chg Grp C v Grp A"))), value= "4")
      textInput("pr3", div(h5(tags$span(style="color:blue", "Prop Chg Grp D v Grp A"))), value= "8")
 
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   # orange button
   actionButton("resamplex",   "Hit to simulate a new sample")
      
   #  tags$head(
   tags$style(HTML('#resamplex{background-color:orange}'))
   # )
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   
   div(h5(tags$span(style="color:blue", "Enter a level followed by a comma and the level(s) to contrast, eg A,BCD. For example, let's evaluate this contrast,\nthe proportional change\n of B compared to A")))
   splitLayout(
    textInput("qq", div(h5(tags$span(style="color:blue", ""))), value= "B,A"),
    
    )

   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   
   output$text99 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "The design matrix for ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", inference()$i )
    
  ))
})
   
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       
   output$text100 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "The design matrix for ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", inference()$j )

  ))
})
   
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   
output$text101 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "The design matrix for the subtraction ") 
    
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", inference()$i ) ,

                tags$span(style="color:black;font-weight:bold;font-size: 20px;", " - ") 
  
     , tags$span(style="color:blue;font-weight:bold;font-size: 20px;", inference()$j )     
    
    ,   tags$span(style="color:black;font-weight:bold;font-size: 20px;", " with intercept added (aka weights) ") 
    
    
  ))
     
})
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


   output$text102 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "The betas ") 
      
  ))
})
    
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


      output$text103 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "The variance covariance matrix ") 
    
  ))
})
   
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  
      output$text104 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "Matrix multiplication [X] [VARCOV] [X'] and take the square root to get se") 
    
  ))
}) 
      
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      
           output$text105 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "Multiply betas by weights and sum to get the contrast estimate!") 
    
  ))
}) 
      
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            
           output$text106 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "Lower and upper limits (estimate +/- zcrit * se)") 
    
  ))
}) 
      
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           
          output$text107 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "Contrasts of levels with intercept") 
    
  ))
}) 
                 
   #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           
           output$text108 <- renderText({  # create interactive text t1

    print(paste0(   
    
    tags$span(style="color:black;font-weight:bold;font-size: 20px;", 
               
               "The contrast function as specified by user inputs") 
    
  ))
})                 
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


```

Column {data-width=400, height=75}
-----------------------------------------------------------------------
  
### rms package analysis and contrast function
  
```{r top}

 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 h5(htmlOutput("text5"))

 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  renderPrint({
  
    model <- inference()$f
    print(model)
  
  })

 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  h5(htmlOutput("text107"))
  
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   
  renderPrint({
  
    model <- inference()$x
    print(model)
  
  })
  
 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 h5(htmlOutput("text108"))
 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  renderPrint({
  
    model <- inference()$res1
    print(model,X =TRUE) #  print(res1, X=TRUE)
  
  })
  
 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


```

 
-------------------------------------
  
### Walking through the calculation steps for a contrast
  
```{r left1test, eval=TRUE}  
 
 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 h5(htmlOutput("text99"))

 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

renderPrint({

  model <- inference()$Xa
  print(model)

})

 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 h5(htmlOutput("text100"))

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

renderPrint({

  model <- inference()$Xb
  print(model)

})

 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 h5(htmlOutput("text101"))

 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

renderPrint({

  model <- inference()$X2
  print(model)

})

 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 h5(htmlOutput("text102"))

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  renderPrint({
  
    model <- inference()$betas
    print(model)
  
  })

 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 h5(htmlOutput("text103"))

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
  renderPrint({
  
    model <- inference()$var.cov
    print(model)
  
  })

 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 h5(htmlOutput("text105"))
 
 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


  renderPrint({
  
    model <- inference()$est
    print(model)
  
  })

 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 h5(htmlOutput("text104"))


 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   renderPrint({
  
    model <- inference()$se
    print(model)
  
  })

 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 h5(htmlOutput("text106"))
 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  renderPrint({
  
    model <- inference()$lower
    print(model)
  
  })

 #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  renderPrint({
  
    model <- inference()$upper
    print(model)
  
  })

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

random.sample3 <- reactive({
        
        # Dummy line to trigger off button-press
        foo <- input$resamplex
        
        x1 <- input$range1[1]  # size
        x2 <- input$range1[2]
        x3 <- input$range2     # mean
        x5 <- input$range3[1]  # sd
        x6 <- input$range3[2]
        
        zx1 <- as.numeric( eval(parse(text= (input$pr1)) ) )
        zx2 <- as.numeric( eval(parse(text= (input$pr2)) ) )
        zx3 <- as.numeric( eval(parse(text= (input$pr3)) ) )
         
        delta1 <- log(zx1)
        delta2 <- log(zx2)
        delta3 <- log(zx3)
       
        top <-  4  # number of groups

    #----------------------------------------------------
    # seems that I need to use both c(x1,x2) c(x1:x2) so sample function works correctly

    if (x1==x2) {
      
      middle <-  sample(c(x1,x2),   top, replace=TRUE)    # choose top count between sliders 
      
    } else {
      
      middle <-  sample(c(x1:x2),   top, replace=TRUE)    #  
    }
    
    #----------------------------------------------------
    lower <-   x3# groups mean
    #----------------------------------------------------
    
    if (x5==x6) {
      
      replicates <-  sample(c(x5,x6),  top, replace=TRUE )   #group sds
      
    } else {
      
      replicates <-  sample(c(x5:x6),   top, replace=TRUE )   #grp sds
      
    }
    #----------------------------------------------------




temp <- rep(lower, top)
#-----------------------------------------------------------------------

  x <- matrix(data = NA, nrow = 4, ncol = 2, byrow = FALSE,
            dimnames = NULL)
 
 #transform to normal distributions
 for( i in 1:4) {
   x[i,] <- unlist(normal_to_lognormal(normmean=temp[i], normsd=replicates[i]))
   }
  
 # get the sds
 replicates <- x[,2]  
 
 x[1,1] -> mu  # intercept
 lower <- c(mu, mu+delta1, mu+delta2, mu+delta3)  # true means

#-----------------------
 
  Nj    <- sum(middle)                        # sum each group size 
  
  muJ   <- rep(lower, times=rep(middle))      # expand means by group sizes
  
  sds   <- rep(replicates, times=rep(middle)) # expand sd by group sizes
  
  grpnames <- LETTERS[1:4]
  
  IV <- factor( rep( grpnames, times=rep(middle) ) )
  
  d <- data.frame(IV=IV,
                  mu= muJ, 
                  sd= sds,
                  x=1
  )
  
  
  d$DV = rlnorm(d$x, meanlog=d$mu, sdlog = d$sd)  # create the response
  
  df <- as.data.frame(d)
  
  dd <- arrange(df, IV)    # sort and create for better order
  
  dd$x <- NULL
  
  # ddz <<- datadist(dd) ;    options(datadist='ddz')
  # f <- ols(log(DV) ~ IV, dd)

  return(list(dd=dd ))

})



# reported in text5

inference <- reactive({
        
    df <-  random.sample3()$dd
   
    ddz <<- datadist(df) ;    options(datadist='ddz')
    
    fit <- ols(log(DV) ~ IV, df)

    x0 <- summary(fit)
    x <-  exp(x0[,4]) # plain 
    
    
    # cc <- contrast(f, list(IV='B', IV='D'),
    #                   list(IV='A', IV='C'), 
    #          type='average',
    #          conf.int=.9)
    # 
    # 
    # exp(cc$Contrast)
        
   # ------------------------------------contrast
    
    # lt <- levels(df$IV)
   qq <-    input$qq
    
   i <- gsub("^(.*?),.*", "\\1", qq)  # pull out before comma
   j <- sub('.*,\\s*', '', qq)        # pull out after comma
    
    a =  list(IV= dput(strsplit(i, "")[[1]])   )
    b =  list(IV= dput(strsplit(j, "")[[1]])   )
   
   #-------------------------------------------------
   
   res1 <- contrast(fit, 
      
        a,
        b,
           
       conf.int=0.95,  #weights=table(df$IV),
                  type='average') 
  
   des.mat <-  print(res1, X=TRUE)
   
    estx <- exp(res1$Contrast[1][[1]])
    L <-    exp(res1$Lower[1][[1]])
    H <-    exp(res1$Upper[1][[1]])
    # ------------------------------------
 
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # let's do the manual contrast after examining Harrell's contract.rms
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
   
   conf.int = 0.95

    # choosing critical value either t or z 
    zcrit <- if (length(idf <- fit$df.residual)) 
      qt((1 + conf.int)/2, idf) else qnorm((1 + conf.int)/2)
  
    betas <- coef(fit)  # all model coefficients
     
    nrp <- num.intercepts(fit, "var")  # should be 1 for this simple case

    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # design matrix
    pred <- function(d) {
          predict(fit, d, type = "x")
    }
    
    # left side
    da <- do.call("gendata", list(fit, factors = a, expand = TRUE)) # creates a df of levels of intrest
    xa <- pred(da)    # will give a design matrix
 
    # right side
    db <- do.call("gendata", list(fit, factors = b, expand = TRUE))
    xb <- pred(db)     # will give a design matrix
      
    ma <- nrow(xa)
    mb <- nrow(xb)
    
     mall <- c(ma, mb)
    
    # if you dont do this design matrices could be wrong
      mm <- max(mall)
    if (mm > 1 && any(mall == 1)) {
        if (ma == 1) 
            xa <- matrix(xa, nrow = mm, ncol = ncol(xa), byrow = TRUE)
        if (mb == 1) 
            xb <- matrix(xb, nrow = mm, ncol = ncol(xb), byrow = TRUE)
      
    }
 
     
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # design matrix difference
    X1 <-  X <- xa - xb  # subtract   X1 will be outputted for presentation
    
    m <- nrow(X)
    
    # binding column of zeros
    if (nrp > 0)  X <- cbind(matrix(0, nrow = m, ncol = nrp), X)

    weights <- rep(1, m)          ## 1 1
    weights <- as.vector(weights)  # 1 1
    
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    X2 <- X <- matrix(    # X2 will be outputted for presentation
        apply(weights * X, 2, sum)/sum(weights), 
                  nrow = 1, dimnames = list(NULL, dimnames(X)[[2]]))
     
      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~contrast
    
      X   # [1x4]  this is the weights!   #  0  0.5   -1  0.5
      
      # weight the betas and sum to get contrast
      est <- matxv(X, betas)   # contrast X %*% betas
      
      #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~variance

      var.cov <- vcov(fit, regcoef.only = TRUE)   # 4X4

      v <- X %*% var.cov %*% t(X)  # variance!!   [1x4] x [4X4] x [4X1]
      
      ndf <- if (is.matrix(v))  nrow(v) else 1    # TRUE  #1
      
      se <- as.vector(if (ndf == 1) sqrt(v) else sqrt(diag(v))  )  
      
      Z <- est/se                                  # standard normal
      
      P <- if (length(idf)) 2 * pt(-abs(Z), idf)  else 2 * pnorm(-abs(Z))
      
      lower <- est - zcrit * se
      upper <- est + zcrit * se
  
    # printed on right tab  
    resxx <- list(Contrast = est, SE = se, Lower = lower, Upper = upper, 
                Z = Z, Pvalue = P,  
                var = v, 
                df.residual = idf, 
                X = X, 
               conf.int = conf.int
                 )
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    # end manual contrast
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    
    
  return(list(
    
         res=estx , L=L, H=H, i=i, j=j, res1=res1,
         
         f=fit, x=x, des.mat=des.mat,
         
         resx=resxx,  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         
         Xa=xa, Xb=xb, weights=weights, X1=X1, X2=X2, betas=betas,
         var.cov=var.cov, est=est, se=se, lower=lower,
         
         upper=upper
              
              ))   
        
})


    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


```  

<!-- tab 6   -->
<!-- ==== -->

<!-- Column {.sidebar} -->
<!-- ----------------------------------------------------------------------- -->

<!-- xxxxxxxxxxxx -->

<!-- ```{r A, eval=TRUE} -->


<!-- ``` -->

<!-- Row {data-height=275} -->
<!-- ----------------------------------------------------------------------- -->

<!-- ### xxxxxxxxxxxxxxxx -->
  

<!-- ```{r B, eval=TRUE} -->


<!-- ``` -->

<!-- Row {data-height=250} -->
<!-- ----------------------------------------------------------------------- -->

<!-- ### xxxx -->


<!-- ```{r C, eval=TRUE} -->


<!-- ``` -->

   
<!-- Row {.tabset .tabset-fade} -->
<!-- ----------------------------------------------------------------------- -->

<!-- ### xxxx -->
  

<!-- ```{r D, eval=TRUE} -->


<!-- ``` -->

<!-- ### xxxx -->

<!-- ```{r E} -->


<!-- ``` -->


Wiki
====
 
<!-- x $\alpha$ x  -->
 

```{r}

  # --------------------------------------------------------------------------

output$text.wiki <- renderText({  # create interactive text t1

    print(paste0(   
 
           tags$span(style="color:black;font-weight:bold;font-size: 20px;",
               
    " Method comparison is presented on the first tab. A simple experiment in which any difference is constant across the range and the standard deviation is also constant and common to both methods. Correlation between samples analysed using both methods can be introduced. If methods agree we expect there to be positive correlation. That is, if one method measures a sample to have a high value we would expect the second method to have a similar high value. We present a plot of the data using boxplots and join the same sample with a thin line, beside it a simple scattterplot. Bottom right the default plot is the familiar Bland Altman plot with 95% limits of agreement and conversion equation. There is an option to show instead the inference on a scatter plot. There are user options too for the analysis, bottom left. Here, the difference can be analysed depending on the averages assuming it is constant (default) or linear. The standard deviation can be analysed depending on the averages assuming it is constant (default) or linear
    ", #),
    
        ".") ))
 })
 

  # --------------------------------------------------------------------------

output$text.wiki2 <- renderText({  # create interactive text t1

    print(paste0(   
  
    
     tags$span(style="color:black;font-weight:bold;font-size: 20px;",
               
    " Method comparison diagnostics are presented on the next tab. The diagnostics include a check of the assmptions of constant variance across the range and constant difference across the range. Below there are more tabs, the first two plots are repeated but with some small modifications (just for programming practice). There is also a tab including histogram of the differences
    ", #),
    
    
        ".") ))
 })
 
  # --------------------------------------------------------------------------

  # --------------------------------------------------------------------------

output$text.wiki3 <- renderText({  # create interactive text t1

    print(paste0(   
  
    
     tags$span(style="color:black;font-weight:bold;font-size: 20px;",
               
    " The T test example tab allows the user to define a lognormal distributed variable (mean, sd and sample size) and another lognormal distributed variable of the same sample size and sd but proportionally different as defined by the user input. There are also user inputs for the confidence level and QC level. At the top we plot in blue the A group on the original scale (left) and log transformed scale. The B group is plotted similarly. At the bottom we plot boxplots (remember this is unpaired data). Also there are inferential statistics above the boxplots
    ", #),
    
    
        ".") ))
 })

output$text.wiki4 <- renderText({  # create interactive text t1

    print(paste0(   
  
    
     tags$span(style="color:black;font-weight:bold;font-size: 20px;",
               
    " The Anova tab allows the user to define 4 lognormal distributed variables of user defined sample sizes, sds and proportional differences.  The idea behind this tab is to perform and understand contrasts. On the left is Frank Harrell's contrast function and on the right we step through how a contrast is calculated
    ", #),
    
    
        ".") ))
 })

output$text.wiki2do <- renderText({  # create interactive text t1

    print(paste0(   
  
    
     tags$span(style="color:black;font-weight:bold;font-size: 20px;",
               
    "  
      vickers code\n
      diagnostis for ANOVA\n
      reference\n
       pi/2 explanation\n
 gelmans book residuals\n
replicates\n
drop some reps\n
anova diagnostics\n
ttest diagnostics\n
    ", #),
    
    
        ".") ))
 })
 
 
  # --------------------------------------------------------------------------

  h5(htmlOutput("text.wiki"))

  h5(htmlOutput("text.wiki2"))
  
  h5(htmlOutput("text.wiki3"))
  
  h5(htmlOutput("text.wiki4"))

  h5(htmlOutput("text.wiki2do"))
  # --------------------------------------------------------------------------

    
```



References
====
```{r, refs}
 
    tags$a(href = "https://pubmed.ncbi.nlm.nih.gov/8337548/", target="_blank",
           tags$span(style="color:blue", "[1] Construction of age-related reference centiles using absolute residuals, Doug Altman shows how to model the SD"),) 
    div(p(" "))
    # tags$a(href = "https://stats.stackexchange.com/questions/27869/fitting-a-poisson-glm-mixed-model-with-a-random-slope-and-intercept",target="_blank",
    #        tags$span(style="color:blue", "[2] Mixed model Poisson"),)
    # div(p(" "))
    
    div(p(" "))
  tags$hr()                        

```